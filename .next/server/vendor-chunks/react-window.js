"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-window";
exports.ids = ["vendor-chunks/react-window"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-window/dist/index.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-window/dist/index.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedSizeGrid: () => (/* binding */ FixedSizeGrid),\n/* harmony export */   FixedSizeList: () => (/* binding */ FixedSizeList),\n/* harmony export */   VariableSizeGrid: () => (/* binding */ VariableSizeGrid),\n/* harmony export */   VariableSizeList: () => (/* binding */ VariableSizeList),\n/* harmony export */   areEqual: () => (/* binding */ areEqual),\n/* harmony export */   shouldComponentUpdate: () => (/* binding */ shouldComponentUpdate)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n\n\n\n\n\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\nvar now = hasNativePerformanceNow ? function() {\n    return performance.now();\n} : function() {\n    return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n    cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n    var start = now();\n    function tick() {\n        if (now() - start >= delay) {\n            callback.call(null);\n        } else {\n            timeoutID.id = requestAnimationFrame(tick);\n        }\n    }\n    var timeoutID = {\n        id: requestAnimationFrame(tick)\n    };\n    return timeoutID;\n}\nvar size = -1; // This utility copied from \"dom-helpers\" package.\nfunction getScrollbarSize(recalculate) {\n    if (recalculate === void 0) {\n        recalculate = false;\n    }\n    if (size === -1 || recalculate) {\n        var div = document.createElement(\"div\");\n        var style = div.style;\n        style.width = \"50px\";\n        style.height = \"50px\";\n        style.overflow = \"scroll\";\n        document.body.appendChild(div);\n        size = div.offsetWidth - div.clientWidth;\n        document.body.removeChild(div);\n    }\n    return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nfunction getRTLOffsetType(recalculate) {\n    if (recalculate === void 0) {\n        recalculate = false;\n    }\n    if (cachedRTLResult === null || recalculate) {\n        var outerDiv = document.createElement(\"div\");\n        var outerStyle = outerDiv.style;\n        outerStyle.width = \"50px\";\n        outerStyle.height = \"50px\";\n        outerStyle.overflow = \"scroll\";\n        outerStyle.direction = \"rtl\";\n        var innerDiv = document.createElement(\"div\");\n        var innerStyle = innerDiv.style;\n        innerStyle.width = \"100px\";\n        innerStyle.height = \"100px\";\n        outerDiv.appendChild(innerDiv);\n        document.body.appendChild(outerDiv);\n        if (outerDiv.scrollLeft > 0) {\n            cachedRTLResult = \"positive-descending\";\n        } else {\n            outerDiv.scrollLeft = 1;\n            if (outerDiv.scrollLeft === 0) {\n                cachedRTLResult = \"negative\";\n            } else {\n                cachedRTLResult = \"positive-ascending\";\n            }\n        }\n        document.body.removeChild(outerDiv);\n        return cachedRTLResult;\n    }\n    return cachedRTLResult;\n}\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\nvar defaultItemKey = function defaultItemKey(_ref) {\n    var columnIndex = _ref.columnIndex, data = _ref.data, rowIndex = _ref.rowIndex;\n    return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\nif (true) {\n    if (false) {}\n}\nfunction createGridComponent(_ref2) {\n    var _class;\n    var getColumnOffset = _ref2.getColumnOffset, getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset, getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex, getColumnWidth = _ref2.getColumnWidth, getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight, getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth, getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment, getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment, getRowHeight = _ref2.getRowHeight, getRowOffset = _ref2.getRowOffset, getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset, getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex, initInstanceProps = _ref2.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange, validateProps = _ref2.validateProps;\n    return _class = /*#__PURE__*/ function(_PureComponent) {\n        (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Grid, _PureComponent);\n        // Always use explicit constructor for React components.\n        // It produces less code after transpilation. (#26)\n        // eslint-disable-next-line no-useless-constructor\n        function Grid(props) {\n            var _this;\n            _this = _PureComponent.call(this, props) || this;\n            _this._instanceProps = initInstanceProps(_this.props, (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this));\n            _this._resetIsScrollingTimeoutId = null;\n            _this._outerRef = void 0;\n            _this.state = {\n                instance: (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this),\n                isScrolling: false,\n                horizontalScrollDirection: \"forward\",\n                scrollLeft: typeof _this.props.initialScrollLeft === \"number\" ? _this.props.initialScrollLeft : 0,\n                scrollTop: typeof _this.props.initialScrollTop === \"number\" ? _this.props.initialScrollTop : 0,\n                scrollUpdateWasRequested: false,\n                verticalScrollDirection: \"forward\"\n            };\n            _this._callOnItemsRendered = void 0;\n            _this._callOnItemsRendered = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n                return _this.props.onItemsRendered({\n                    overscanColumnStartIndex: overscanColumnStartIndex,\n                    overscanColumnStopIndex: overscanColumnStopIndex,\n                    overscanRowStartIndex: overscanRowStartIndex,\n                    overscanRowStopIndex: overscanRowStopIndex,\n                    visibleColumnStartIndex: visibleColumnStartIndex,\n                    visibleColumnStopIndex: visibleColumnStopIndex,\n                    visibleRowStartIndex: visibleRowStartIndex,\n                    visibleRowStopIndex: visibleRowStopIndex\n                });\n            });\n            _this._callOnScroll = void 0;\n            _this._callOnScroll = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n                return _this.props.onScroll({\n                    horizontalScrollDirection: horizontalScrollDirection,\n                    scrollLeft: scrollLeft,\n                    scrollTop: scrollTop,\n                    verticalScrollDirection: verticalScrollDirection,\n                    scrollUpdateWasRequested: scrollUpdateWasRequested\n                });\n            });\n            _this._getItemStyle = void 0;\n            _this._getItemStyle = function(rowIndex, columnIndex) {\n                var _this$props = _this.props, columnWidth = _this$props.columnWidth, direction = _this$props.direction, rowHeight = _this$props.rowHeight;\n                var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n                var key = rowIndex + \":\" + columnIndex;\n                var style;\n                if (itemStyleCache.hasOwnProperty(key)) {\n                    style = itemStyleCache[key];\n                } else {\n                    var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n                    var isRtl = direction === \"rtl\";\n                    itemStyleCache[key] = style = {\n                        position: \"absolute\",\n                        left: isRtl ? undefined : _offset,\n                        right: isRtl ? _offset : undefined,\n                        top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n                        height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n                        width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n                    };\n                }\n                return style;\n            };\n            _this._getItemStyleCache = void 0;\n            _this._getItemStyleCache = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(_, __, ___) {\n                return {};\n            });\n            _this._onScroll = function(event) {\n                var _event$currentTarget = event.currentTarget, clientHeight = _event$currentTarget.clientHeight, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollTop = _event$currentTarget.scrollTop, scrollHeight = _event$currentTarget.scrollHeight, scrollWidth = _event$currentTarget.scrollWidth;\n                _this.setState(function(prevState) {\n                    if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n                        // Scroll position may have been updated by cDM/cDU,\n                        // In which case we don't need to trigger another render,\n                        // And we don't want to update state.isScrolling.\n                        return null;\n                    }\n                    var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                    // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                    // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n                    // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n                    var calculatedScrollLeft = scrollLeft;\n                    if (direction === \"rtl\") {\n                        switch(getRTLOffsetType()){\n                            case \"negative\":\n                                calculatedScrollLeft = -scrollLeft;\n                                break;\n                            case \"positive-descending\":\n                                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                                break;\n                        }\n                    } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                    calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n                    var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n                    return {\n                        isScrolling: true,\n                        horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? \"forward\" : \"backward\",\n                        scrollLeft: calculatedScrollLeft,\n                        scrollTop: calculatedScrollTop,\n                        verticalScrollDirection: prevState.scrollTop < scrollTop ? \"forward\" : \"backward\",\n                        scrollUpdateWasRequested: false\n                    };\n                }, _this._resetIsScrollingDebounced);\n            };\n            _this._outerRefSetter = function(ref) {\n                var outerRef = _this.props.outerRef;\n                _this._outerRef = ref;\n                if (typeof outerRef === \"function\") {\n                    outerRef(ref);\n                } else if (outerRef != null && typeof outerRef === \"object\" && outerRef.hasOwnProperty(\"current\")) {\n                    outerRef.current = ref;\n                }\n            };\n            _this._resetIsScrollingDebounced = function() {\n                if (_this._resetIsScrollingTimeoutId !== null) {\n                    cancelTimeout(_this._resetIsScrollingTimeoutId);\n                }\n                _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n            };\n            _this._resetIsScrolling = function() {\n                _this._resetIsScrollingTimeoutId = null;\n                _this.setState({\n                    isScrolling: false\n                }, function() {\n                    // Clear style cache after state update has been committed.\n                    // This way we don't break pure sCU for items that don't use isScrolling param.\n                    _this._getItemStyleCache(-1);\n                });\n            };\n            return _this;\n        }\n        Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n            validateSharedProps(nextProps, prevState);\n            validateProps(nextProps);\n            return null;\n        };\n        var _proto = Grid.prototype;\n        _proto.scrollTo = function scrollTo(_ref3) {\n            var scrollLeft = _ref3.scrollLeft, scrollTop = _ref3.scrollTop;\n            if (scrollLeft !== undefined) {\n                scrollLeft = Math.max(0, scrollLeft);\n            }\n            if (scrollTop !== undefined) {\n                scrollTop = Math.max(0, scrollTop);\n            }\n            this.setState(function(prevState) {\n                if (scrollLeft === undefined) {\n                    scrollLeft = prevState.scrollLeft;\n                }\n                if (scrollTop === undefined) {\n                    scrollTop = prevState.scrollTop;\n                }\n                if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n                    return null;\n                }\n                return {\n                    horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? \"forward\" : \"backward\",\n                    scrollLeft: scrollLeft,\n                    scrollTop: scrollTop,\n                    scrollUpdateWasRequested: true,\n                    verticalScrollDirection: prevState.scrollTop < scrollTop ? \"forward\" : \"backward\"\n                };\n            }, this._resetIsScrollingDebounced);\n        };\n        _proto.scrollToItem = function scrollToItem(_ref4) {\n            var _ref4$align = _ref4.align, align = _ref4$align === void 0 ? \"auto\" : _ref4$align, columnIndex = _ref4.columnIndex, rowIndex = _ref4.rowIndex;\n            var _this$props2 = this.props, columnCount = _this$props2.columnCount, height = _this$props2.height, rowCount = _this$props2.rowCount, width = _this$props2.width;\n            var _this$state = this.state, scrollLeft = _this$state.scrollLeft, scrollTop = _this$state.scrollTop;\n            var scrollbarSize = getScrollbarSize();\n            if (columnIndex !== undefined) {\n                columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n            }\n            if (rowIndex !== undefined) {\n                rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n            }\n            var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n            var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n            // to ensure it's fully visible.\n            // But we only need to account for its size when it's actually visible.\n            var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n            var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n            this.scrollTo({\n                scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n                scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n            });\n        };\n        _proto.componentDidMount = function componentDidMount() {\n            var _this$props3 = this.props, initialScrollLeft = _this$props3.initialScrollLeft, initialScrollTop = _this$props3.initialScrollTop;\n            if (this._outerRef != null) {\n                var outerRef = this._outerRef;\n                if (typeof initialScrollLeft === \"number\") {\n                    outerRef.scrollLeft = initialScrollLeft;\n                }\n                if (typeof initialScrollTop === \"number\") {\n                    outerRef.scrollTop = initialScrollTop;\n                }\n            }\n            this._callPropsCallbacks();\n        };\n        _proto.componentDidUpdate = function componentDidUpdate() {\n            var direction = this.props.direction;\n            var _this$state2 = this.state, scrollLeft = _this$state2.scrollLeft, scrollTop = _this$state2.scrollTop, scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n            if (scrollUpdateWasRequested && this._outerRef != null) {\n                // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                // So we need to determine which browser behavior we're dealing with, and mimic it.\n                var outerRef = this._outerRef;\n                if (direction === \"rtl\") {\n                    switch(getRTLOffsetType()){\n                        case \"negative\":\n                            outerRef.scrollLeft = -scrollLeft;\n                            break;\n                        case \"positive-ascending\":\n                            outerRef.scrollLeft = scrollLeft;\n                            break;\n                        default:\n                            var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;\n                            outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                            break;\n                    }\n                } else {\n                    outerRef.scrollLeft = Math.max(0, scrollLeft);\n                }\n                outerRef.scrollTop = Math.max(0, scrollTop);\n            }\n            this._callPropsCallbacks();\n        };\n        _proto.componentWillUnmount = function componentWillUnmount() {\n            if (this._resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this._resetIsScrollingTimeoutId);\n            }\n        };\n        _proto.render = function render() {\n            var _this$props4 = this.props, children = _this$props4.children, className = _this$props4.className, columnCount = _this$props4.columnCount, direction = _this$props4.direction, height = _this$props4.height, innerRef = _this$props4.innerRef, innerElementType = _this$props4.innerElementType, innerTagName = _this$props4.innerTagName, itemData = _this$props4.itemData, _this$props4$itemKey = _this$props4.itemKey, itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey, outerElementType = _this$props4.outerElementType, outerTagName = _this$props4.outerTagName, rowCount = _this$props4.rowCount, style = _this$props4.style, useIsScrolling = _this$props4.useIsScrolling, width = _this$props4.width;\n            var isScrolling = this.state.isScrolling;\n            var _this$_getHorizontalR = this._getHorizontalRangeToRender(), columnStartIndex = _this$_getHorizontalR[0], columnStopIndex = _this$_getHorizontalR[1];\n            var _this$_getVerticalRan = this._getVerticalRangeToRender(), rowStartIndex = _this$_getVerticalRan[0], rowStopIndex = _this$_getVerticalRan[1];\n            var items = [];\n            if (columnCount > 0 && rowCount) {\n                for(var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++){\n                    for(var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++){\n                        items.push(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(children, {\n                            columnIndex: _columnIndex,\n                            data: itemData,\n                            isScrolling: useIsScrolling ? isScrolling : undefined,\n                            key: itemKey({\n                                columnIndex: _columnIndex,\n                                data: itemData,\n                                rowIndex: _rowIndex\n                            }),\n                            rowIndex: _rowIndex,\n                            style: this._getItemStyle(_rowIndex, _columnIndex)\n                        }));\n                    }\n                }\n            } // Read this value AFTER items have been created,\n            // So their actual sizes (if variable) are taken into consideration.\n            var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n            var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(outerElementType || outerTagName || \"div\", {\n                className: className,\n                onScroll: this._onScroll,\n                ref: this._outerRefSetter,\n                style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n                    position: \"relative\",\n                    height: height,\n                    width: width,\n                    overflow: \"auto\",\n                    WebkitOverflowScrolling: \"touch\",\n                    willChange: \"transform\",\n                    direction: direction\n                }, style)\n            }, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(innerElementType || innerTagName || \"div\", {\n                children: items,\n                ref: innerRef,\n                style: {\n                    height: estimatedTotalHeight,\n                    pointerEvents: isScrolling ? \"none\" : undefined,\n                    width: estimatedTotalWidth\n                }\n            }));\n        };\n        _proto._callPropsCallbacks = function _callPropsCallbacks() {\n            var _this$props5 = this.props, columnCount = _this$props5.columnCount, onItemsRendered = _this$props5.onItemsRendered, onScroll = _this$props5.onScroll, rowCount = _this$props5.rowCount;\n            if (typeof onItemsRendered === \"function\") {\n                if (columnCount > 0 && rowCount > 0) {\n                    var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(), _overscanColumnStartIndex = _this$_getHorizontalR2[0], _overscanColumnStopIndex = _this$_getHorizontalR2[1], _visibleColumnStartIndex = _this$_getHorizontalR2[2], _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n                    var _this$_getVerticalRan2 = this._getVerticalRangeToRender(), _overscanRowStartIndex = _this$_getVerticalRan2[0], _overscanRowStopIndex = _this$_getVerticalRan2[1], _visibleRowStartIndex = _this$_getVerticalRan2[2], _visibleRowStopIndex = _this$_getVerticalRan2[3];\n                    this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n                }\n            }\n            if (typeof onScroll === \"function\") {\n                var _this$state3 = this.state, _horizontalScrollDirection = _this$state3.horizontalScrollDirection, _scrollLeft = _this$state3.scrollLeft, _scrollTop = _this$state3.scrollTop, _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested, _verticalScrollDirection = _this$state3.verticalScrollDirection;\n                this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n            }\n        } // Lazily create and cache item styles while scrolling,\n        ;\n        _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n            var _this$props6 = this.props, columnCount = _this$props6.columnCount, overscanColumnCount = _this$props6.overscanColumnCount, overscanColumnsCount = _this$props6.overscanColumnsCount, overscanCount = _this$props6.overscanCount, rowCount = _this$props6.rowCount;\n            var _this$state4 = this.state, horizontalScrollDirection = _this$state4.horizontalScrollDirection, isScrolling = _this$state4.isScrolling, scrollLeft = _this$state4.scrollLeft;\n            var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n            if (columnCount === 0 || rowCount === 0) {\n                return [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n            var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n            // If there isn't at least one extra item, tab loops back around.\n            var overscanBackward = !isScrolling || horizontalScrollDirection === \"backward\" ? Math.max(1, overscanCountResolved) : 1;\n            var overscanForward = !isScrolling || horizontalScrollDirection === \"forward\" ? Math.max(1, overscanCountResolved) : 1;\n            return [\n                Math.max(0, startIndex - overscanBackward),\n                Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\n                startIndex,\n                stopIndex\n            ];\n        };\n        _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n            var _this$props7 = this.props, columnCount = _this$props7.columnCount, overscanCount = _this$props7.overscanCount, overscanRowCount = _this$props7.overscanRowCount, overscanRowsCount = _this$props7.overscanRowsCount, rowCount = _this$props7.rowCount;\n            var _this$state5 = this.state, isScrolling = _this$state5.isScrolling, verticalScrollDirection = _this$state5.verticalScrollDirection, scrollTop = _this$state5.scrollTop;\n            var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n            if (columnCount === 0 || rowCount === 0) {\n                return [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n            var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n            // If there isn't at least one extra item, tab loops back around.\n            var overscanBackward = !isScrolling || verticalScrollDirection === \"backward\" ? Math.max(1, overscanCountResolved) : 1;\n            var overscanForward = !isScrolling || verticalScrollDirection === \"forward\" ? Math.max(1, overscanCountResolved) : 1;\n            return [\n                Math.max(0, startIndex - overscanBackward),\n                Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\n                startIndex,\n                stopIndex\n            ];\n        };\n        return Grid;\n    }(react__WEBPACK_IMPORTED_MODULE_3__.PureComponent), _class.defaultProps = {\n        direction: \"ltr\",\n        itemData: undefined,\n        useIsScrolling: false\n    }, _class;\n}\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n    var children = _ref5.children, direction = _ref5.direction, height = _ref5.height, innerTagName = _ref5.innerTagName, outerTagName = _ref5.outerTagName, overscanColumnsCount = _ref5.overscanColumnsCount, overscanCount = _ref5.overscanCount, overscanRowsCount = _ref5.overscanRowsCount, width = _ref5.width;\n    var instance = _ref6.instance;\n    if (true) {\n        if (typeof overscanCount === \"number\") {\n            if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n                devWarningsOverscanCount.add(instance);\n                console.warn(\"The overscanCount prop has been deprecated. \" + \"Please use the overscanColumnCount and overscanRowCount props instead.\");\n            }\n        }\n        if (typeof overscanColumnsCount === \"number\" || typeof overscanRowsCount === \"number\") {\n            if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n                devWarningsOverscanRowsColumnsCount.add(instance);\n                console.warn(\"The overscanColumnsCount and overscanRowsCount props have been deprecated. \" + \"Please use the overscanColumnCount and overscanRowCount props instead.\");\n            }\n        }\n        if (innerTagName != null || outerTagName != null) {\n            if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n                devWarningsTagName.add(instance);\n                console.warn(\"The innerTagName and outerTagName props have been deprecated. \" + \"Please use the innerElementType and outerElementType props instead.\");\n            }\n        }\n        if (children == null) {\n            throw Error('An invalid \"children\" prop has been specified. ' + \"Value should be a React component. \" + ('\"' + (children === null ? \"null\" : typeof children) + '\" was specified.'));\n        }\n        switch(direction){\n            case \"ltr\":\n            case \"rtl\":\n                break;\n            default:\n                throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + ('\"' + direction + '\" was specified.'));\n        }\n        if (typeof width !== \"number\") {\n            throw Error('An invalid \"width\" prop has been specified. ' + \"Grids must specify a number for width. \" + ('\"' + (width === null ? \"null\" : typeof width) + '\" was specified.'));\n        }\n        if (typeof height !== \"number\") {\n            throw Error('An invalid \"height\" prop has been specified. ' + \"Grids must specify a number for height. \" + ('\"' + (height === null ? \"null\" : typeof height) + '\" was specified.'));\n        }\n    }\n};\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n    var rowCount = _ref.rowCount;\n    var rowMetadataMap = _ref2.rowMetadataMap, estimatedRowHeight = _ref2.estimatedRowHeight, lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n    var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n    // https://github.com/bvaughn/react-window/pull/138\n    if (lastMeasuredRowIndex >= rowCount) {\n        lastMeasuredRowIndex = rowCount - 1;\n    }\n    if (lastMeasuredRowIndex >= 0) {\n        var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n        totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n    }\n    var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n    var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n    return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n    var columnCount = _ref3.columnCount;\n    var columnMetadataMap = _ref4.columnMetadataMap, estimatedColumnWidth = _ref4.estimatedColumnWidth, lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n    var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n    // https://github.com/bvaughn/react-window/pull/138\n    if (lastMeasuredColumnIndex >= columnCount) {\n        lastMeasuredColumnIndex = columnCount - 1;\n    }\n    if (lastMeasuredColumnIndex >= 0) {\n        var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n        totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n    }\n    var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n    var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n    return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n    var itemMetadataMap, itemSize, lastMeasuredIndex;\n    if (itemType === \"column\") {\n        itemMetadataMap = instanceProps.columnMetadataMap;\n        itemSize = props.columnWidth;\n        lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n    } else {\n        itemMetadataMap = instanceProps.rowMetadataMap;\n        itemSize = props.rowHeight;\n        lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n    }\n    if (index > lastMeasuredIndex) {\n        var offset = 0;\n        if (lastMeasuredIndex >= 0) {\n            var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n            offset = itemMetadata.offset + itemMetadata.size;\n        }\n        for(var i = lastMeasuredIndex + 1; i <= index; i++){\n            var size = itemSize(i);\n            itemMetadataMap[i] = {\n                offset: offset,\n                size: size\n            };\n            offset += size;\n        }\n        if (itemType === \"column\") {\n            instanceProps.lastMeasuredColumnIndex = index;\n        } else {\n            instanceProps.lastMeasuredRowIndex = index;\n        }\n    }\n    return itemMetadataMap[index];\n};\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n    var itemMetadataMap, lastMeasuredIndex;\n    if (itemType === \"column\") {\n        itemMetadataMap = instanceProps.columnMetadataMap;\n        lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n    } else {\n        itemMetadataMap = instanceProps.rowMetadataMap;\n        lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n    }\n    var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n    if (lastMeasuredItemOffset >= offset) {\n        // If we've already measured items within this range just use a binary search as it's faster.\n        return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n    } else {\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n        // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n        // The overall complexity for this approach is O(log n).\n        return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n    }\n};\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n    while(low <= high){\n        var middle = low + Math.floor((high - low) / 2);\n        var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n        if (currentOffset === offset) {\n            return middle;\n        } else if (currentOffset < offset) {\n            low = middle + 1;\n        } else if (currentOffset > offset) {\n            high = middle - 1;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n    var itemCount = itemType === \"column\" ? props.columnCount : props.rowCount;\n    var interval = 1;\n    while(index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset){\n        index += interval;\n        interval *= 2;\n    }\n    return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var size = itemType === \"column\" ? props.width : props.height;\n    var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    var estimatedTotalSize = itemType === \"column\" ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n    if (align === \"smart\") {\n        if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n            align = \"auto\";\n        } else {\n            align = \"center\";\n        }\n    }\n    switch(align){\n        case \"start\":\n            return maxOffset;\n        case \"end\":\n            return minOffset;\n        case \"center\":\n            return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        case \"auto\":\n        default:\n            if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n                return scrollOffset;\n            } else if (minOffset > maxOffset) {\n                // Because we only take into account the scrollbar size when calculating minOffset\n                // this value can be larger than maxOffset when at the end of the list\n                return minOffset;\n            } else if (scrollOffset < minOffset) {\n                return minOffset;\n            } else {\n                return maxOffset;\n            }\n    }\n};\nvar VariableSizeGrid = /*#__PURE__*/ createGridComponent({\n    getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n        return getItemMetadata(\"column\", props, index, instanceProps).offset;\n    },\n    getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n        return findNearestItem(\"column\", props, instanceProps, scrollLeft);\n    },\n    getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n        var columnCount = props.columnCount, width = props.width;\n        var itemMetadata = getItemMetadata(\"column\", props, startIndex, instanceProps);\n        var maxOffset = scrollLeft + width;\n        var offset = itemMetadata.offset + itemMetadata.size;\n        var stopIndex = startIndex;\n        while(stopIndex < columnCount - 1 && offset < maxOffset){\n            stopIndex++;\n            offset += getItemMetadata(\"column\", props, stopIndex, instanceProps).size;\n        }\n        return stopIndex;\n    },\n    getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n        return instanceProps.columnMetadataMap[index].size;\n    },\n    getEstimatedTotalHeight: getEstimatedTotalHeight,\n    getEstimatedTotalWidth: getEstimatedTotalWidth,\n    getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n        return getOffsetForIndexAndAlignment(\"column\", props, index, align, scrollOffset, instanceProps, scrollbarSize);\n    },\n    getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n        return getOffsetForIndexAndAlignment(\"row\", props, index, align, scrollOffset, instanceProps, scrollbarSize);\n    },\n    getRowOffset: function getRowOffset(props, index, instanceProps) {\n        return getItemMetadata(\"row\", props, index, instanceProps).offset;\n    },\n    getRowHeight: function getRowHeight(props, index, instanceProps) {\n        return instanceProps.rowMetadataMap[index].size;\n    },\n    getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n        return findNearestItem(\"row\", props, instanceProps, scrollTop);\n    },\n    getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n        var rowCount = props.rowCount, height = props.height;\n        var itemMetadata = getItemMetadata(\"row\", props, startIndex, instanceProps);\n        var maxOffset = scrollTop + height;\n        var offset = itemMetadata.offset + itemMetadata.size;\n        var stopIndex = startIndex;\n        while(stopIndex < rowCount - 1 && offset < maxOffset){\n            stopIndex++;\n            offset += getItemMetadata(\"row\", props, stopIndex, instanceProps).size;\n        }\n        return stopIndex;\n    },\n    initInstanceProps: function initInstanceProps(props, instance) {\n        var _ref5 = props, estimatedColumnWidth = _ref5.estimatedColumnWidth, estimatedRowHeight = _ref5.estimatedRowHeight;\n        var instanceProps = {\n            columnMetadataMap: {},\n            estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n            estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n            lastMeasuredColumnIndex: -1,\n            lastMeasuredRowIndex: -1,\n            rowMetadataMap: {}\n        };\n        instance.resetAfterColumnIndex = function(columnIndex, shouldForceUpdate) {\n            if (shouldForceUpdate === void 0) {\n                shouldForceUpdate = true;\n            }\n            instance.resetAfterIndices({\n                columnIndex: columnIndex,\n                shouldForceUpdate: shouldForceUpdate\n            });\n        };\n        instance.resetAfterRowIndex = function(rowIndex, shouldForceUpdate) {\n            if (shouldForceUpdate === void 0) {\n                shouldForceUpdate = true;\n            }\n            instance.resetAfterIndices({\n                rowIndex: rowIndex,\n                shouldForceUpdate: shouldForceUpdate\n            });\n        };\n        instance.resetAfterIndices = function(_ref6) {\n            var columnIndex = _ref6.columnIndex, rowIndex = _ref6.rowIndex, _ref6$shouldForceUpda = _ref6.shouldForceUpdate, shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n            if (typeof columnIndex === \"number\") {\n                instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n            }\n            if (typeof rowIndex === \"number\") {\n                instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n            } // We could potentially optimize further by only evicting styles after this index,\n            // But since styles are only cached while scrolling is in progress-\n            // It seems an unnecessary optimization.\n            // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n            instance._getItemStyleCache(-1);\n            if (shouldForceUpdate) {\n                instance.forceUpdate();\n            }\n        };\n        return instanceProps;\n    },\n    shouldResetStyleCacheOnItemSizeChange: false,\n    validateProps: function validateProps(_ref7) {\n        var columnWidth = _ref7.columnWidth, rowHeight = _ref7.rowHeight;\n        if (true) {\n            if (typeof columnWidth !== \"function\") {\n                throw Error('An invalid \"columnWidth\" prop has been specified. ' + \"Value should be a function. \" + ('\"' + (columnWidth === null ? \"null\" : typeof columnWidth) + '\" was specified.'));\n            } else if (typeof rowHeight !== \"function\") {\n                throw Error('An invalid \"rowHeight\" prop has been specified. ' + \"Value should be a function. \" + ('\"' + (rowHeight === null ? \"null\" : typeof rowHeight) + '\" was specified.'));\n            }\n        }\n    }\n});\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n    return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\nif (true) {\n    if (false) {}\n}\nfunction createListComponent(_ref) {\n    var _class;\n    var getItemOffset = _ref.getItemOffset, getEstimatedTotalSize = _ref.getEstimatedTotalSize, getItemSize = _ref.getItemSize, getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment, getStartIndexForOffset = _ref.getStartIndexForOffset, getStopIndexForStartIndex = _ref.getStopIndexForStartIndex, initInstanceProps = _ref.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange, validateProps = _ref.validateProps;\n    return _class = /*#__PURE__*/ function(_PureComponent) {\n        (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(List, _PureComponent);\n        // Always use explicit constructor for React components.\n        // It produces less code after transpilation. (#26)\n        // eslint-disable-next-line no-useless-constructor\n        function List(props) {\n            var _this;\n            _this = _PureComponent.call(this, props) || this;\n            _this._instanceProps = initInstanceProps(_this.props, (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this));\n            _this._outerRef = void 0;\n            _this._resetIsScrollingTimeoutId = null;\n            _this.state = {\n                instance: (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this),\n                isScrolling: false,\n                scrollDirection: \"forward\",\n                scrollOffset: typeof _this.props.initialScrollOffset === \"number\" ? _this.props.initialScrollOffset : 0,\n                scrollUpdateWasRequested: false\n            };\n            _this._callOnItemsRendered = void 0;\n            _this._callOnItemsRendered = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n                return _this.props.onItemsRendered({\n                    overscanStartIndex: overscanStartIndex,\n                    overscanStopIndex: overscanStopIndex,\n                    visibleStartIndex: visibleStartIndex,\n                    visibleStopIndex: visibleStopIndex\n                });\n            });\n            _this._callOnScroll = void 0;\n            _this._callOnScroll = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n                return _this.props.onScroll({\n                    scrollDirection: scrollDirection,\n                    scrollOffset: scrollOffset,\n                    scrollUpdateWasRequested: scrollUpdateWasRequested\n                });\n            });\n            _this._getItemStyle = void 0;\n            _this._getItemStyle = function(index) {\n                var _this$props = _this.props, direction = _this$props.direction, itemSize = _this$props.itemSize, layout = _this$props.layout;\n                var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n                var style;\n                if (itemStyleCache.hasOwnProperty(index)) {\n                    style = itemStyleCache[index];\n                } else {\n                    var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n                    var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n                    var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n                    var isRtl = direction === \"rtl\";\n                    var offsetHorizontal = isHorizontal ? _offset : 0;\n                    itemStyleCache[index] = style = {\n                        position: \"absolute\",\n                        left: isRtl ? undefined : offsetHorizontal,\n                        right: isRtl ? offsetHorizontal : undefined,\n                        top: !isHorizontal ? _offset : 0,\n                        height: !isHorizontal ? size : \"100%\",\n                        width: isHorizontal ? size : \"100%\"\n                    };\n                }\n                return style;\n            };\n            _this._getItemStyleCache = void 0;\n            _this._getItemStyleCache = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(_, __, ___) {\n                return {};\n            });\n            _this._onScrollHorizontal = function(event) {\n                var _event$currentTarget = event.currentTarget, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollWidth = _event$currentTarget.scrollWidth;\n                _this.setState(function(prevState) {\n                    if (prevState.scrollOffset === scrollLeft) {\n                        // Scroll position may have been updated by cDM/cDU,\n                        // In which case we don't need to trigger another render,\n                        // And we don't want to update state.isScrolling.\n                        return null;\n                    }\n                    var direction = _this.props.direction;\n                    var scrollOffset = scrollLeft;\n                    if (direction === \"rtl\") {\n                        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n                        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n                        switch(getRTLOffsetType()){\n                            case \"negative\":\n                                scrollOffset = -scrollLeft;\n                                break;\n                            case \"positive-descending\":\n                                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                                break;\n                        }\n                    } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                    scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n                    return {\n                        isScrolling: true,\n                        scrollDirection: prevState.scrollOffset < scrollOffset ? \"forward\" : \"backward\",\n                        scrollOffset: scrollOffset,\n                        scrollUpdateWasRequested: false\n                    };\n                }, _this._resetIsScrollingDebounced);\n            };\n            _this._onScrollVertical = function(event) {\n                var _event$currentTarget2 = event.currentTarget, clientHeight = _event$currentTarget2.clientHeight, scrollHeight = _event$currentTarget2.scrollHeight, scrollTop = _event$currentTarget2.scrollTop;\n                _this.setState(function(prevState) {\n                    if (prevState.scrollOffset === scrollTop) {\n                        // Scroll position may have been updated by cDM/cDU,\n                        // In which case we don't need to trigger another render,\n                        // And we don't want to update state.isScrolling.\n                        return null;\n                    } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                    var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n                    return {\n                        isScrolling: true,\n                        scrollDirection: prevState.scrollOffset < scrollOffset ? \"forward\" : \"backward\",\n                        scrollOffset: scrollOffset,\n                        scrollUpdateWasRequested: false\n                    };\n                }, _this._resetIsScrollingDebounced);\n            };\n            _this._outerRefSetter = function(ref) {\n                var outerRef = _this.props.outerRef;\n                _this._outerRef = ref;\n                if (typeof outerRef === \"function\") {\n                    outerRef(ref);\n                } else if (outerRef != null && typeof outerRef === \"object\" && outerRef.hasOwnProperty(\"current\")) {\n                    outerRef.current = ref;\n                }\n            };\n            _this._resetIsScrollingDebounced = function() {\n                if (_this._resetIsScrollingTimeoutId !== null) {\n                    cancelTimeout(_this._resetIsScrollingTimeoutId);\n                }\n                _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n            };\n            _this._resetIsScrolling = function() {\n                _this._resetIsScrollingTimeoutId = null;\n                _this.setState({\n                    isScrolling: false\n                }, function() {\n                    // Clear style cache after state update has been committed.\n                    // This way we don't break pure sCU for items that don't use isScrolling param.\n                    _this._getItemStyleCache(-1, null);\n                });\n            };\n            return _this;\n        }\n        List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n            validateSharedProps$1(nextProps, prevState);\n            validateProps(nextProps);\n            return null;\n        };\n        var _proto = List.prototype;\n        _proto.scrollTo = function scrollTo(scrollOffset) {\n            scrollOffset = Math.max(0, scrollOffset);\n            this.setState(function(prevState) {\n                if (prevState.scrollOffset === scrollOffset) {\n                    return null;\n                }\n                return {\n                    scrollDirection: prevState.scrollOffset < scrollOffset ? \"forward\" : \"backward\",\n                    scrollOffset: scrollOffset,\n                    scrollUpdateWasRequested: true\n                };\n            }, this._resetIsScrollingDebounced);\n        };\n        _proto.scrollToItem = function scrollToItem(index, align) {\n            if (align === void 0) {\n                align = \"auto\";\n            }\n            var _this$props2 = this.props, itemCount = _this$props2.itemCount, layout = _this$props2.layout;\n            var scrollOffset = this.state.scrollOffset;\n            index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n            // But we only need to account for its size when it's actually visible.\n            // This is an edge case for lists; normally they only scroll in the dominant direction.\n            var scrollbarSize = 0;\n            if (this._outerRef) {\n                var outerRef = this._outerRef;\n                if (layout === \"vertical\") {\n                    scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;\n                } else {\n                    scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;\n                }\n            }\n            this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));\n        };\n        _proto.componentDidMount = function componentDidMount() {\n            var _this$props3 = this.props, direction = _this$props3.direction, initialScrollOffset = _this$props3.initialScrollOffset, layout = _this$props3.layout;\n            if (typeof initialScrollOffset === \"number\" && this._outerRef != null) {\n                var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n                if (direction === \"horizontal\" || layout === \"horizontal\") {\n                    outerRef.scrollLeft = initialScrollOffset;\n                } else {\n                    outerRef.scrollTop = initialScrollOffset;\n                }\n            }\n            this._callPropsCallbacks();\n        };\n        _proto.componentDidUpdate = function componentDidUpdate() {\n            var _this$props4 = this.props, direction = _this$props4.direction, layout = _this$props4.layout;\n            var _this$state = this.state, scrollOffset = _this$state.scrollOffset, scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n            if (scrollUpdateWasRequested && this._outerRef != null) {\n                var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n                if (direction === \"horizontal\" || layout === \"horizontal\") {\n                    if (direction === \"rtl\") {\n                        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                        // So we need to determine which browser behavior we're dealing with, and mimic it.\n                        switch(getRTLOffsetType()){\n                            case \"negative\":\n                                outerRef.scrollLeft = -scrollOffset;\n                                break;\n                            case \"positive-ascending\":\n                                outerRef.scrollLeft = scrollOffset;\n                                break;\n                            default:\n                                var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;\n                                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                                break;\n                        }\n                    } else {\n                        outerRef.scrollLeft = scrollOffset;\n                    }\n                } else {\n                    outerRef.scrollTop = scrollOffset;\n                }\n            }\n            this._callPropsCallbacks();\n        };\n        _proto.componentWillUnmount = function componentWillUnmount() {\n            if (this._resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this._resetIsScrollingTimeoutId);\n            }\n        };\n        _proto.render = function render() {\n            var _this$props5 = this.props, children = _this$props5.children, className = _this$props5.className, direction = _this$props5.direction, height = _this$props5.height, innerRef = _this$props5.innerRef, innerElementType = _this$props5.innerElementType, innerTagName = _this$props5.innerTagName, itemCount = _this$props5.itemCount, itemData = _this$props5.itemData, _this$props5$itemKey = _this$props5.itemKey, itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey, layout = _this$props5.layout, outerElementType = _this$props5.outerElementType, outerTagName = _this$props5.outerTagName, style = _this$props5.style, useIsScrolling = _this$props5.useIsScrolling, width = _this$props5.width;\n            var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n            var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n            var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n            var _this$_getRangeToRend = this._getRangeToRender(), startIndex = _this$_getRangeToRend[0], stopIndex = _this$_getRangeToRend[1];\n            var items = [];\n            if (itemCount > 0) {\n                for(var _index = startIndex; _index <= stopIndex; _index++){\n                    items.push(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(children, {\n                        data: itemData,\n                        key: itemKey(_index, itemData),\n                        index: _index,\n                        isScrolling: useIsScrolling ? isScrolling : undefined,\n                        style: this._getItemStyle(_index)\n                    }));\n                }\n            } // Read this value AFTER items have been created,\n            // So their actual sizes (if variable) are taken into consideration.\n            var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(outerElementType || outerTagName || \"div\", {\n                className: className,\n                onScroll: onScroll,\n                ref: this._outerRefSetter,\n                style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n                    position: \"relative\",\n                    height: height,\n                    width: width,\n                    overflow: \"auto\",\n                    WebkitOverflowScrolling: \"touch\",\n                    willChange: \"transform\",\n                    direction: direction\n                }, style)\n            }, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(innerElementType || innerTagName || \"div\", {\n                children: items,\n                ref: innerRef,\n                style: {\n                    height: isHorizontal ? \"100%\" : estimatedTotalSize,\n                    pointerEvents: isScrolling ? \"none\" : undefined,\n                    width: isHorizontal ? estimatedTotalSize : \"100%\"\n                }\n            }));\n        };\n        _proto._callPropsCallbacks = function _callPropsCallbacks() {\n            if (typeof this.props.onItemsRendered === \"function\") {\n                var itemCount = this.props.itemCount;\n                if (itemCount > 0) {\n                    var _this$_getRangeToRend2 = this._getRangeToRender(), _overscanStartIndex = _this$_getRangeToRend2[0], _overscanStopIndex = _this$_getRangeToRend2[1], _visibleStartIndex = _this$_getRangeToRend2[2], _visibleStopIndex = _this$_getRangeToRend2[3];\n                    this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n                }\n            }\n            if (typeof this.props.onScroll === \"function\") {\n                var _this$state2 = this.state, _scrollDirection = _this$state2.scrollDirection, _scrollOffset = _this$state2.scrollOffset, _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n                this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n            }\n        } // Lazily create and cache item styles while scrolling,\n        ;\n        _proto._getRangeToRender = function _getRangeToRender() {\n            var _this$props6 = this.props, itemCount = _this$props6.itemCount, overscanCount = _this$props6.overscanCount;\n            var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollDirection = _this$state3.scrollDirection, scrollOffset = _this$state3.scrollOffset;\n            if (itemCount === 0) {\n                return [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n            var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n            // If there isn't at least one extra item, tab loops back around.\n            var overscanBackward = !isScrolling || scrollDirection === \"backward\" ? Math.max(1, overscanCount) : 1;\n            var overscanForward = !isScrolling || scrollDirection === \"forward\" ? Math.max(1, overscanCount) : 1;\n            return [\n                Math.max(0, startIndex - overscanBackward),\n                Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n                startIndex,\n                stopIndex\n            ];\n        };\n        return List;\n    }(react__WEBPACK_IMPORTED_MODULE_3__.PureComponent), _class.defaultProps = {\n        direction: \"ltr\",\n        itemData: undefined,\n        layout: \"vertical\",\n        overscanCount: 2,\n        useIsScrolling: false\n    }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n    var children = _ref2.children, direction = _ref2.direction, height = _ref2.height, layout = _ref2.layout, innerTagName = _ref2.innerTagName, outerTagName = _ref2.outerTagName, width = _ref2.width;\n    var instance = _ref3.instance;\n    if (true) {\n        if (innerTagName != null || outerTagName != null) {\n            if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n                devWarningsTagName$1.add(instance);\n                console.warn(\"The innerTagName and outerTagName props have been deprecated. \" + \"Please use the innerElementType and outerElementType props instead.\");\n            }\n        } // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        switch(direction){\n            case \"horizontal\":\n            case \"vertical\":\n                if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n                    devWarningsDirection.add(instance);\n                    console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n                }\n                break;\n            case \"ltr\":\n            case \"rtl\":\n                break;\n            default:\n                throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + ('\"' + direction + '\" was specified.'));\n        }\n        switch(layout){\n            case \"horizontal\":\n            case \"vertical\":\n                break;\n            default:\n                throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + ('\"' + layout + '\" was specified.'));\n        }\n        if (children == null) {\n            throw Error('An invalid \"children\" prop has been specified. ' + \"Value should be a React component. \" + ('\"' + (children === null ? \"null\" : typeof children) + '\" was specified.'));\n        }\n        if (isHorizontal && typeof width !== \"number\") {\n            throw Error('An invalid \"width\" prop has been specified. ' + \"Horizontal lists must specify a number for width. \" + ('\"' + (width === null ? \"null\" : typeof width) + '\" was specified.'));\n        } else if (!isHorizontal && typeof height !== \"number\") {\n            throw Error('An invalid \"height\" prop has been specified. ' + \"Vertical lists must specify a number for height. \" + ('\"' + (height === null ? \"null\" : typeof height) + '\" was specified.'));\n        }\n    }\n};\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n    var _ref = props, itemSize = _ref.itemSize;\n    var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n    if (index > lastMeasuredIndex) {\n        var offset = 0;\n        if (lastMeasuredIndex >= 0) {\n            var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n            offset = itemMetadata.offset + itemMetadata.size;\n        }\n        for(var i = lastMeasuredIndex + 1; i <= index; i++){\n            var size = itemSize(i);\n            itemMetadataMap[i] = {\n                offset: offset,\n                size: size\n            };\n            offset += size;\n        }\n        instanceProps.lastMeasuredIndex = index;\n    }\n    return itemMetadataMap[index];\n};\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n    var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n    var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n    if (lastMeasuredItemOffset >= offset) {\n        // If we've already measured items within this range just use a binary search as it's faster.\n        return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n    } else {\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n        // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n        // The overall complexity for this approach is O(log n).\n        return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n    }\n};\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n    while(low <= high){\n        var middle = low + Math.floor((high - low) / 2);\n        var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n        if (currentOffset === offset) {\n            return middle;\n        } else if (currentOffset < offset) {\n            low = middle + 1;\n        } else if (currentOffset > offset) {\n            high = middle - 1;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n    var itemCount = props.itemCount;\n    var interval = 1;\n    while(index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset){\n        index += interval;\n        interval *= 2;\n    }\n    return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n    var itemCount = _ref2.itemCount;\n    var itemMetadataMap = _ref3.itemMetadataMap, estimatedItemSize = _ref3.estimatedItemSize, lastMeasuredIndex = _ref3.lastMeasuredIndex;\n    var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n    // https://github.com/bvaughn/react-window/pull/138\n    if (lastMeasuredIndex >= itemCount) {\n        lastMeasuredIndex = itemCount - 1;\n    }\n    if (lastMeasuredIndex >= 0) {\n        var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n        totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n    }\n    var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n    var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n    return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nvar VariableSizeList = /*#__PURE__*/ createListComponent({\n    getItemOffset: function getItemOffset(props, index, instanceProps) {\n        return getItemMetadata$1(props, index, instanceProps).offset;\n    },\n    getItemSize: function getItemSize(props, index, instanceProps) {\n        return instanceProps.itemMetadataMap[index].size;\n    },\n    getEstimatedTotalSize: getEstimatedTotalSize,\n    getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n        var direction = props.direction, height = props.height, layout = props.layout, width = props.width; // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        var size = isHorizontal ? width : height;\n        var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n        // To ensure it reflects actual measurements instead of just estimates.\n        var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n        var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n        var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);\n        if (align === \"smart\") {\n            if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n                align = \"auto\";\n            } else {\n                align = \"center\";\n            }\n        }\n        switch(align){\n            case \"start\":\n                return maxOffset;\n            case \"end\":\n                return minOffset;\n            case \"center\":\n                return Math.round(minOffset + (maxOffset - minOffset) / 2);\n            case \"auto\":\n            default:\n                if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n                    return scrollOffset;\n                } else if (scrollOffset < minOffset) {\n                    return minOffset;\n                } else {\n                    return maxOffset;\n                }\n        }\n    },\n    getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n        return findNearestItem$1(props, instanceProps, offset);\n    },\n    getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n        var direction = props.direction, height = props.height, itemCount = props.itemCount, layout = props.layout, width = props.width; // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        var size = isHorizontal ? width : height;\n        var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n        var maxOffset = scrollOffset + size;\n        var offset = itemMetadata.offset + itemMetadata.size;\n        var stopIndex = startIndex;\n        while(stopIndex < itemCount - 1 && offset < maxOffset){\n            stopIndex++;\n            offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n        }\n        return stopIndex;\n    },\n    initInstanceProps: function initInstanceProps(props, instance) {\n        var _ref4 = props, estimatedItemSize = _ref4.estimatedItemSize;\n        var instanceProps = {\n            itemMetadataMap: {},\n            estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n            lastMeasuredIndex: -1\n        };\n        instance.resetAfterIndex = function(index, shouldForceUpdate) {\n            if (shouldForceUpdate === void 0) {\n                shouldForceUpdate = true;\n            }\n            instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n            // But since styles are only cached while scrolling is in progress-\n            // It seems an unnecessary optimization.\n            // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n            instance._getItemStyleCache(-1);\n            if (shouldForceUpdate) {\n                instance.forceUpdate();\n            }\n        };\n        return instanceProps;\n    },\n    shouldResetStyleCacheOnItemSizeChange: false,\n    validateProps: function validateProps(_ref5) {\n        var itemSize = _ref5.itemSize;\n        if (true) {\n            if (typeof itemSize !== \"function\") {\n                throw Error('An invalid \"itemSize\" prop has been specified. ' + \"Value should be a function. \" + ('\"' + (itemSize === null ? \"null\" : typeof itemSize) + '\" was specified.'));\n            }\n        }\n    }\n});\nvar FixedSizeGrid = /*#__PURE__*/ createGridComponent({\n    getColumnOffset: function getColumnOffset(_ref, index) {\n        var columnWidth = _ref.columnWidth;\n        return index * columnWidth;\n    },\n    getColumnWidth: function getColumnWidth(_ref2, index) {\n        var columnWidth = _ref2.columnWidth;\n        return columnWidth;\n    },\n    getRowOffset: function getRowOffset(_ref3, index) {\n        var rowHeight = _ref3.rowHeight;\n        return index * rowHeight;\n    },\n    getRowHeight: function getRowHeight(_ref4, index) {\n        var rowHeight = _ref4.rowHeight;\n        return rowHeight;\n    },\n    getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n        var rowCount = _ref5.rowCount, rowHeight = _ref5.rowHeight;\n        return rowHeight * rowCount;\n    },\n    getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n        var columnCount = _ref6.columnCount, columnWidth = _ref6.columnWidth;\n        return columnWidth * columnCount;\n    },\n    getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n        var columnCount = _ref7.columnCount, columnWidth = _ref7.columnWidth, width = _ref7.width;\n        var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n        var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n        var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n        if (align === \"smart\") {\n            if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n                align = \"auto\";\n            } else {\n                align = \"center\";\n            }\n        }\n        switch(align){\n            case \"start\":\n                return maxOffset;\n            case \"end\":\n                return minOffset;\n            case \"center\":\n                // \"Centered\" offset is usually the average of the min and max.\n                // But near the edges of the list, this doesn't hold true.\n                var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n                if (middleOffset < Math.ceil(width / 2)) {\n                    return 0; // near the beginning\n                } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n                    return lastColumnOffset; // near the end\n                } else {\n                    return middleOffset;\n                }\n            case \"auto\":\n            default:\n                if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n                    return scrollLeft;\n                } else if (minOffset > maxOffset) {\n                    // Because we only take into account the scrollbar size when calculating minOffset\n                    // this value can be larger than maxOffset when at the end of the list\n                    return minOffset;\n                } else if (scrollLeft < minOffset) {\n                    return minOffset;\n                } else {\n                    return maxOffset;\n                }\n        }\n    },\n    getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n        var rowHeight = _ref8.rowHeight, height = _ref8.height, rowCount = _ref8.rowCount;\n        var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n        var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n        var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n        if (align === \"smart\") {\n            if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n                align = \"auto\";\n            } else {\n                align = \"center\";\n            }\n        }\n        switch(align){\n            case \"start\":\n                return maxOffset;\n            case \"end\":\n                return minOffset;\n            case \"center\":\n                // \"Centered\" offset is usually the average of the min and max.\n                // But near the edges of the list, this doesn't hold true.\n                var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n                if (middleOffset < Math.ceil(height / 2)) {\n                    return 0; // near the beginning\n                } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n                    return lastRowOffset; // near the end\n                } else {\n                    return middleOffset;\n                }\n            case \"auto\":\n            default:\n                if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n                    return scrollTop;\n                } else if (minOffset > maxOffset) {\n                    // Because we only take into account the scrollbar size when calculating minOffset\n                    // this value can be larger than maxOffset when at the end of the list\n                    return minOffset;\n                } else if (scrollTop < minOffset) {\n                    return minOffset;\n                } else {\n                    return maxOffset;\n                }\n        }\n    },\n    getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n        var columnWidth = _ref9.columnWidth, columnCount = _ref9.columnCount;\n        return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n    },\n    getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n        var columnWidth = _ref10.columnWidth, columnCount = _ref10.columnCount, width = _ref10.width;\n        var left = startIndex * columnWidth;\n        var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n        return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n        ));\n    },\n    getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n        var rowHeight = _ref11.rowHeight, rowCount = _ref11.rowCount;\n        return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n    },\n    getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n        var rowHeight = _ref12.rowHeight, rowCount = _ref12.rowCount, height = _ref12.height;\n        var top = startIndex * rowHeight;\n        var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n        return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n        ));\n    },\n    initInstanceProps: function initInstanceProps(props) {},\n    shouldResetStyleCacheOnItemSizeChange: true,\n    validateProps: function validateProps(_ref13) {\n        var columnWidth = _ref13.columnWidth, rowHeight = _ref13.rowHeight;\n        if (true) {\n            if (typeof columnWidth !== \"number\") {\n                throw Error('An invalid \"columnWidth\" prop has been specified. ' + \"Value should be a number. \" + ('\"' + (columnWidth === null ? \"null\" : typeof columnWidth) + '\" was specified.'));\n            }\n            if (typeof rowHeight !== \"number\") {\n                throw Error('An invalid \"rowHeight\" prop has been specified. ' + \"Value should be a number. \" + ('\"' + (rowHeight === null ? \"null\" : typeof rowHeight) + '\" was specified.'));\n            }\n        }\n    }\n});\nvar FixedSizeList = /*#__PURE__*/ createListComponent({\n    getItemOffset: function getItemOffset(_ref, index) {\n        var itemSize = _ref.itemSize;\n        return index * itemSize;\n    },\n    getItemSize: function getItemSize(_ref2, index) {\n        var itemSize = _ref2.itemSize;\n        return itemSize;\n    },\n    getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n        var itemCount = _ref3.itemCount, itemSize = _ref3.itemSize;\n        return itemSize * itemCount;\n    },\n    getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {\n        var direction = _ref4.direction, height = _ref4.height, itemCount = _ref4.itemCount, itemSize = _ref4.itemSize, layout = _ref4.layout, width = _ref4.width;\n        // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        var size = isHorizontal ? width : height;\n        var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n        var maxOffset = Math.min(lastItemOffset, index * itemSize);\n        var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);\n        if (align === \"smart\") {\n            if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n                align = \"auto\";\n            } else {\n                align = \"center\";\n            }\n        }\n        switch(align){\n            case \"start\":\n                return maxOffset;\n            case \"end\":\n                return minOffset;\n            case \"center\":\n                {\n                    // \"Centered\" offset is usually the average of the min and max.\n                    // But near the edges of the list, this doesn't hold true.\n                    var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n                    if (middleOffset < Math.ceil(size / 2)) {\n                        return 0; // near the beginning\n                    } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n                        return lastItemOffset; // near the end\n                    } else {\n                        return middleOffset;\n                    }\n                }\n            case \"auto\":\n            default:\n                if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n                    return scrollOffset;\n                } else if (scrollOffset < minOffset) {\n                    return minOffset;\n                } else {\n                    return maxOffset;\n                }\n        }\n    },\n    getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n        var itemCount = _ref5.itemCount, itemSize = _ref5.itemSize;\n        return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n    },\n    getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n        var direction = _ref6.direction, height = _ref6.height, itemCount = _ref6.itemCount, itemSize = _ref6.itemSize, layout = _ref6.layout, width = _ref6.width;\n        // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        var offset = startIndex * itemSize;\n        var size = isHorizontal ? width : height;\n        var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n        return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n        ));\n    },\n    initInstanceProps: function initInstanceProps(props) {},\n    shouldResetStyleCacheOnItemSizeChange: true,\n    validateProps: function validateProps(_ref7) {\n        var itemSize = _ref7.itemSize;\n        if (true) {\n            if (typeof itemSize !== \"number\") {\n                throw Error('An invalid \"itemSize\" prop has been specified. ' + \"Value should be a number. \" + ('\"' + (itemSize === null ? \"null\" : typeof itemSize) + '\" was specified.'));\n            }\n        }\n    }\n});\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n    for(var attribute in prev){\n        if (!(attribute in next)) {\n            return true;\n        }\n    }\n    for(var _attribute in next){\n        if (prev[_attribute] !== next[_attribute]) {\n            return true;\n        }\n    }\n    return false;\n}\nvar _excluded = [\n    \"style\"\n], _excluded2 = [\n    \"style\"\n];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\nfunction areEqual(prevProps, nextProps) {\n    var prevStyle = prevProps.style, prevRest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(prevProps, _excluded);\n    var nextStyle = nextProps.style, nextRest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(nextProps, _excluded2);\n    return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\nfunction shouldComponentUpdate(nextProps, nextState) {\n    return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtd2luZG93L2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDNEI7QUFDaEI7QUFDakM7QUFDZ0I7QUFDK0M7QUFFcEcsc0RBQXNEO0FBQ3RELDZGQUE2RjtBQUM3RixJQUFJTywwQkFBMEIsT0FBT0MsZ0JBQWdCLFlBQVksT0FBT0EsWUFBWUMsR0FBRyxLQUFLO0FBQzVGLElBQUlBLE1BQU1GLDBCQUEwQjtJQUNsQyxPQUFPQyxZQUFZQyxHQUFHO0FBQ3hCLElBQUk7SUFDRixPQUFPQyxLQUFLRCxHQUFHO0FBQ2pCO0FBQ0EsU0FBU0UsY0FBY0MsU0FBUztJQUM5QkMscUJBQXFCRCxVQUFVRSxFQUFFO0FBQ25DO0FBQ0EsU0FBU0MsZUFBZUMsUUFBUSxFQUFFQyxLQUFLO0lBQ3JDLElBQUlDLFFBQVFUO0lBRVosU0FBU1U7UUFDUCxJQUFJVixRQUFRUyxTQUFTRCxPQUFPO1lBQzFCRCxTQUFTSSxJQUFJLENBQUM7UUFDaEIsT0FBTztZQUNMUixVQUFVRSxFQUFFLEdBQUdPLHNCQUFzQkY7UUFDdkM7SUFDRjtJQUVBLElBQUlQLFlBQVk7UUFDZEUsSUFBSU8sc0JBQXNCRjtJQUM1QjtJQUNBLE9BQU9QO0FBQ1Q7QUFFQSxJQUFJVSxPQUFPLENBQUMsR0FBRyxrREFBa0Q7QUFFakUsU0FBU0MsaUJBQWlCQyxXQUFXO0lBQ25DLElBQUlBLGdCQUFnQixLQUFLLEdBQUc7UUFDMUJBLGNBQWM7SUFDaEI7SUFFQSxJQUFJRixTQUFTLENBQUMsS0FBS0UsYUFBYTtRQUM5QixJQUFJQyxNQUFNQyxTQUFTdEIsYUFBYSxDQUFDO1FBQ2pDLElBQUl1QixRQUFRRixJQUFJRSxLQUFLO1FBQ3JCQSxNQUFNQyxLQUFLLEdBQUc7UUFDZEQsTUFBTUUsTUFBTSxHQUFHO1FBQ2ZGLE1BQU1HLFFBQVEsR0FBRztRQUNqQkosU0FBU0ssSUFBSSxDQUFDQyxXQUFXLENBQUNQO1FBQzFCSCxP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QUFLLEVBQzNCbVUsV0FBV3hWLG1HQUE2QkEsQ0FBQ3VJLFdBQVcyTTtJQUV4RCxPQUFPLENBQUNOLGVBQWVTLFdBQVdFLGNBQWMsQ0FBQ1gsZUFBZVUsVUFBVUU7QUFDNUU7QUFFQSw0RUFBNEU7QUFDNUUsMEVBQTBFO0FBRTFFLFNBQVNDLHNCQUFzQmxOLFNBQVMsRUFBRW1OLFNBQVM7SUFDakQsT0FBTyxDQUFDUCxTQUFTLElBQUksQ0FBQzdRLEtBQUssRUFBRWlFLGNBQWNxTSxlQUFlLElBQUksQ0FBQ2pRLEtBQUssRUFBRStRO0FBQ3hFO0FBRTZHLENBQzdHLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Rva2VuLXB1bHNlLWZpbmFsLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXdpbmRvdy9kaXN0L2luZGV4LmVzbS5qcz9lODY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZCc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgbWVtb2l6ZU9uZSBmcm9tICdtZW1vaXplLW9uZSc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuXG4vLyBBbmltYXRpb24gZnJhbWUgYmFzZWQgaW1wbGVtZW50YXRpb24gb2Ygc2V0VGltZW91dC5cbi8vIEluc3BpcmVkIGJ5IEpvZSBMYW1iZXJ0LCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qb2VsYW1iZXJ0LzEwMDIxMTYjZmlsZS1yZXF1ZXN0dGltZW91dC1qc1xudmFyIGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xudmFyIG5vdyA9IGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93ID8gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG59IDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5mdW5jdGlvbiBjYW5jZWxUaW1lb3V0KHRpbWVvdXRJRCkge1xuICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aW1lb3V0SUQuaWQpO1xufVxuZnVuY3Rpb24gcmVxdWVzdFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KSB7XG4gIHZhciBzdGFydCA9IG5vdygpO1xuXG4gIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgaWYgKG5vdygpIC0gc3RhcnQgPj0gZGVsYXkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJRC5pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGltZW91dElEID0ge1xuICAgIGlkOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljaylcbiAgfTtcbiAgcmV0dXJuIHRpbWVvdXRJRDtcbn1cblxudmFyIHNpemUgPSAtMTsgLy8gVGhpcyB1dGlsaXR5IGNvcGllZCBmcm9tIFwiZG9tLWhlbHBlcnNcIiBwYWNrYWdlLlxuXG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJTaXplKHJlY2FsY3VsYXRlKSB7XG4gIGlmIChyZWNhbGN1bGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmVjYWxjdWxhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChzaXplID09PSAtMSB8fCByZWNhbGN1bGF0ZSkge1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgc3R5bGUgPSBkaXYuc3R5bGU7XG4gICAgc3R5bGUud2lkdGggPSAnNTBweCc7XG4gICAgc3R5bGUuaGVpZ2h0ID0gJzUwcHgnO1xuICAgIHN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIHNpemUgPSBkaXYub2Zmc2V0V2lkdGggLSBkaXYuY2xpZW50V2lkdGg7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICB9XG5cbiAgcmV0dXJuIHNpemU7XG59XG52YXIgY2FjaGVkUlRMUmVzdWx0ID0gbnVsbDsgLy8gVFJJQ0tZIEFjY29yZGluZyB0byB0aGUgc3BlYywgc2Nyb2xsTGVmdCBzaG91bGQgYmUgbmVnYXRpdmUgZm9yIFJUTCBhbGlnbmVkIGVsZW1lbnRzLlxuLy8gQ2hyb21lIGRvZXMgbm90IHNlZW0gdG8gYWRoZXJlOyBpdHMgc2Nyb2xsTGVmdCB2YWx1ZXMgYXJlIHBvc2l0aXZlIChtZWFzdXJlZCByZWxhdGl2ZSB0byB0aGUgbGVmdCkuXG4vLyBTYWZhcmkncyBlbGFzdGljIGJvdW5jZSBtYWtlcyBkZXRlY3RpbmcgdGhpcyBldmVuIG1vcmUgY29tcGxpY2F0ZWQgd3J0IHBvdGVudGlhbCBmYWxzZSBwb3NpdGl2ZXMuXG4vLyBUaGUgc2FmZXN0IHdheSB0byBjaGVjayB0aGlzIGlzIHRvIGludGVudGlvbmFsbHkgc2V0IGEgbmVnYXRpdmUgb2Zmc2V0LFxuLy8gYW5kIHRoZW4gdmVyaWZ5IHRoYXQgdGhlIHN1YnNlcXVlbnQgXCJzY3JvbGxcIiBldmVudCBtYXRjaGVzIHRoZSBuZWdhdGl2ZSBvZmZzZXQuXG4vLyBJZiBpdCBkb2VzIG5vdCBtYXRjaCwgdGhlbiB3ZSBjYW4gYXNzdW1lIGEgbm9uLXN0YW5kYXJkIFJUTCBzY3JvbGwgaW1wbGVtZW50YXRpb24uXG5cbmZ1bmN0aW9uIGdldFJUTE9mZnNldFR5cGUocmVjYWxjdWxhdGUpIHtcbiAgaWYgKHJlY2FsY3VsYXRlID09PSB2b2lkIDApIHtcbiAgICByZWNhbGN1bGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGNhY2hlZFJUTFJlc3VsdCA9PT0gbnVsbCB8fCByZWNhbGN1bGF0ZSkge1xuICAgIHZhciBvdXRlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBvdXRlclN0eWxlID0gb3V0ZXJEaXYuc3R5bGU7XG4gICAgb3V0ZXJTdHlsZS53aWR0aCA9ICc1MHB4JztcbiAgICBvdXRlclN0eWxlLmhlaWdodCA9ICc1MHB4JztcbiAgICBvdXRlclN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gICAgb3V0ZXJTdHlsZS5kaXJlY3Rpb24gPSAncnRsJztcbiAgICB2YXIgaW5uZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgaW5uZXJTdHlsZSA9IGlubmVyRGl2LnN0eWxlO1xuICAgIGlubmVyU3R5bGUud2lkdGggPSAnMTAwcHgnO1xuICAgIGlubmVyU3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAgICBvdXRlckRpdi5hcHBlbmRDaGlsZChpbm5lckRpdik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlckRpdik7XG5cbiAgICBpZiAob3V0ZXJEaXYuc2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgIGNhY2hlZFJUTFJlc3VsdCA9ICdwb3NpdGl2ZS1kZXNjZW5kaW5nJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ZXJEaXYuc2Nyb2xsTGVmdCA9IDE7XG5cbiAgICAgIGlmIChvdXRlckRpdi5zY3JvbGxMZWZ0ID09PSAwKSB7XG4gICAgICAgIGNhY2hlZFJUTFJlc3VsdCA9ICduZWdhdGl2ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZWRSVExSZXN1bHQgPSAncG9zaXRpdmUtYXNjZW5kaW5nJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG91dGVyRGl2KTtcbiAgICByZXR1cm4gY2FjaGVkUlRMUmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlZFJUTFJlc3VsdDtcbn1cblxudmFyIElTX1NDUk9MTElOR19ERUJPVU5DRV9JTlRFUlZBTCA9IDE1MDtcblxudmFyIGRlZmF1bHRJdGVtS2V5ID0gZnVuY3Rpb24gZGVmYXVsdEl0ZW1LZXkoX3JlZikge1xuICB2YXIgY29sdW1uSW5kZXggPSBfcmVmLmNvbHVtbkluZGV4LFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIHJvd0luZGV4ID0gX3JlZi5yb3dJbmRleDtcbiAgcmV0dXJuIHJvd0luZGV4ICsgXCI6XCIgKyBjb2x1bW5JbmRleDtcbn07IC8vIEluIERFViBtb2RlLCB0aGlzIFNldCBoZWxwcyB1cyBvbmx5IGxvZyBhIHdhcm5pbmcgb25jZSBwZXIgY29tcG9uZW50IGluc3RhbmNlLlxuLy8gVGhpcyBhdm9pZHMgc3BhbW1pbmcgdGhlIGNvbnNvbGUgZXZlcnkgdGltZSBhIHJlbmRlciBoYXBwZW5zLlxuXG5cbnZhciBkZXZXYXJuaW5nc092ZXJzY2FuQ291bnQgPSBudWxsO1xudmFyIGRldldhcm5pbmdzT3ZlcnNjYW5Sb3dzQ29sdW1uc0NvdW50ID0gbnVsbDtcbnZhciBkZXZXYXJuaW5nc1RhZ05hbWUgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5XZWFrU2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRldldhcm5pbmdzT3ZlcnNjYW5Db3VudCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xuICAgIGRldldhcm5pbmdzT3ZlcnNjYW5Sb3dzQ29sdW1uc0NvdW50ID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG4gICAgZGV2V2FybmluZ3NUYWdOYW1lID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlR3JpZENvbXBvbmVudChfcmVmMikge1xuICB2YXIgX2NsYXNzO1xuXG4gIHZhciBnZXRDb2x1bW5PZmZzZXQgPSBfcmVmMi5nZXRDb2x1bW5PZmZzZXQsXG4gICAgICBnZXRDb2x1bW5TdGFydEluZGV4Rm9yT2Zmc2V0ID0gX3JlZjIuZ2V0Q29sdW1uU3RhcnRJbmRleEZvck9mZnNldCxcbiAgICAgIGdldENvbHVtblN0b3BJbmRleEZvclN0YXJ0SW5kZXggPSBfcmVmMi5nZXRDb2x1bW5TdG9wSW5kZXhGb3JTdGFydEluZGV4LFxuICAgICAgZ2V0Q29sdW1uV2lkdGggPSBfcmVmMi5nZXRDb2x1bW5XaWR0aCxcbiAgICAgIGdldEVzdGltYXRlZFRvdGFsSGVpZ2h0ID0gX3JlZjIuZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQsXG4gICAgICBnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoID0gX3JlZjIuZ2V0RXN0aW1hdGVkVG90YWxXaWR0aCxcbiAgICAgIGdldE9mZnNldEZvckNvbHVtbkFuZEFsaWdubWVudCA9IF9yZWYyLmdldE9mZnNldEZvckNvbHVtbkFuZEFsaWdubWVudCxcbiAgICAgIGdldE9mZnNldEZvclJvd0FuZEFsaWdubWVudCA9IF9yZWYyLmdldE9mZnNldEZvclJvd0FuZEFsaWdubWVudCxcbiAgICAgIGdldFJvd0hlaWdodCA9IF9yZWYyLmdldFJvd0hlaWdodCxcbiAgICAgIGdldFJvd09mZnNldCA9IF9yZWYyLmdldFJvd09mZnNldCxcbiAgICAgIGdldFJvd1N0YXJ0SW5kZXhGb3JPZmZzZXQgPSBfcmVmMi5nZXRSb3dTdGFydEluZGV4Rm9yT2Zmc2V0LFxuICAgICAgZ2V0Um93U3RvcEluZGV4Rm9yU3RhcnRJbmRleCA9IF9yZWYyLmdldFJvd1N0b3BJbmRleEZvclN0YXJ0SW5kZXgsXG4gICAgICBpbml0SW5zdGFuY2VQcm9wcyA9IF9yZWYyLmluaXRJbnN0YW5jZVByb3BzLFxuICAgICAgc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZSA9IF9yZWYyLnNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UsXG4gICAgICB2YWxpZGF0ZVByb3BzID0gX3JlZjIudmFsaWRhdGVQcm9wcztcbiAgcmV0dXJuIF9jbGFzcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShHcmlkLCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgICAvLyBBbHdheXMgdXNlIGV4cGxpY2l0IGNvbnN0cnVjdG9yIGZvciBSZWFjdCBjb21wb25lbnRzLlxuICAgIC8vIEl0IHByb2R1Y2VzIGxlc3MgY29kZSBhZnRlciB0cmFuc3BpbGF0aW9uLiAoIzI2KVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gR3JpZChwcm9wcykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9QdXJlQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5faW5zdGFuY2VQcm9wcyA9IGluaXRJbnN0YW5jZVByb3BzKF90aGlzLnByb3BzLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICBfdGhpcy5fb3V0ZXJSZWYgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgaW5zdGFuY2U6IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLFxuICAgICAgICBpc1Njcm9sbGluZzogZmFsc2UsXG4gICAgICAgIGhvcml6b250YWxTY3JvbGxEaXJlY3Rpb246ICdmb3J3YXJkJyxcbiAgICAgICAgc2Nyb2xsTGVmdDogdHlwZW9mIF90aGlzLnByb3BzLmluaXRpYWxTY3JvbGxMZWZ0ID09PSAnbnVtYmVyJyA/IF90aGlzLnByb3BzLmluaXRpYWxTY3JvbGxMZWZ0IDogMCxcbiAgICAgICAgc2Nyb2xsVG9wOiB0eXBlb2YgX3RoaXMucHJvcHMuaW5pdGlhbFNjcm9sbFRvcCA9PT0gJ251bWJlcicgPyBfdGhpcy5wcm9wcy5pbml0aWFsU2Nyb2xsVG9wIDogMCxcbiAgICAgICAgc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkOiBmYWxzZSxcbiAgICAgICAgdmVydGljYWxTY3JvbGxEaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgfTtcbiAgICAgIF90aGlzLl9jYWxsT25JdGVtc1JlbmRlcmVkID0gdm9pZCAwO1xuICAgICAgX3RoaXMuX2NhbGxPbkl0ZW1zUmVuZGVyZWQgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChvdmVyc2NhbkNvbHVtblN0YXJ0SW5kZXgsIG92ZXJzY2FuQ29sdW1uU3RvcEluZGV4LCBvdmVyc2NhblJvd1N0YXJ0SW5kZXgsIG92ZXJzY2FuUm93U3RvcEluZGV4LCB2aXNpYmxlQ29sdW1uU3RhcnRJbmRleCwgdmlzaWJsZUNvbHVtblN0b3BJbmRleCwgdmlzaWJsZVJvd1N0YXJ0SW5kZXgsIHZpc2libGVSb3dTdG9wSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9uSXRlbXNSZW5kZXJlZCh7XG4gICAgICAgICAgb3ZlcnNjYW5Db2x1bW5TdGFydEluZGV4OiBvdmVyc2NhbkNvbHVtblN0YXJ0SW5kZXgsXG4gICAgICAgICAgb3ZlcnNjYW5Db2x1bW5TdG9wSW5kZXg6IG92ZXJzY2FuQ29sdW1uU3RvcEluZGV4LFxuICAgICAgICAgIG92ZXJzY2FuUm93U3RhcnRJbmRleDogb3ZlcnNjYW5Sb3dTdGFydEluZGV4LFxuICAgICAgICAgIG92ZXJzY2FuUm93U3RvcEluZGV4OiBvdmVyc2NhblJvd1N0b3BJbmRleCxcbiAgICAgICAgICB2aXNpYmxlQ29sdW1uU3RhcnRJbmRleDogdmlzaWJsZUNvbHVtblN0YXJ0SW5kZXgsXG4gICAgICAgICAgdmlzaWJsZUNvbHVtblN0b3BJbmRleDogdmlzaWJsZUNvbHVtblN0b3BJbmRleCxcbiAgICAgICAgICB2aXNpYmxlUm93U3RhcnRJbmRleDogdmlzaWJsZVJvd1N0YXJ0SW5kZXgsXG4gICAgICAgICAgdmlzaWJsZVJvd1N0b3BJbmRleDogdmlzaWJsZVJvd1N0b3BJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuX2NhbGxPblNjcm9sbCA9IHZvaWQgMDtcbiAgICAgIF90aGlzLl9jYWxsT25TY3JvbGwgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIGhvcml6b250YWxTY3JvbGxEaXJlY3Rpb24sIHZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uLCBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9uU2Nyb2xsKHtcbiAgICAgICAgICBob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uOiBob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uLFxuICAgICAgICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3AsXG4gICAgICAgICAgdmVydGljYWxTY3JvbGxEaXJlY3Rpb246IHZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uLFxuICAgICAgICAgIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDogc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5fZ2V0SXRlbVN0eWxlID0gdm9pZCAwO1xuXG4gICAgICBfdGhpcy5fZ2V0SXRlbVN0eWxlID0gZnVuY3Rpb24gKHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGNvbHVtbldpZHRoID0gX3RoaXMkcHJvcHMuY29sdW1uV2lkdGgsXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBfdGhpcyRwcm9wcy5kaXJlY3Rpb24sXG4gICAgICAgICAgICByb3dIZWlnaHQgPSBfdGhpcyRwcm9wcy5yb3dIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGl0ZW1TdHlsZUNhY2hlID0gX3RoaXMuX2dldEl0ZW1TdHlsZUNhY2hlKHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UgJiYgY29sdW1uV2lkdGgsIHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UgJiYgZGlyZWN0aW9uLCBzaG91bGRSZXNldFN0eWxlQ2FjaGVPbkl0ZW1TaXplQ2hhbmdlICYmIHJvd0hlaWdodCk7XG5cbiAgICAgICAgdmFyIGtleSA9IHJvd0luZGV4ICsgXCI6XCIgKyBjb2x1bW5JbmRleDtcbiAgICAgICAgdmFyIHN0eWxlO1xuXG4gICAgICAgIGlmIChpdGVtU3R5bGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgc3R5bGUgPSBpdGVtU3R5bGVDYWNoZVtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfb2Zmc2V0ID0gZ2V0Q29sdW1uT2Zmc2V0KF90aGlzLnByb3BzLCBjb2x1bW5JbmRleCwgX3RoaXMuX2luc3RhbmNlUHJvcHMpO1xuXG4gICAgICAgICAgdmFyIGlzUnRsID0gZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgICBpdGVtU3R5bGVDYWNoZVtrZXldID0gc3R5bGUgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGxlZnQ6IGlzUnRsID8gdW5kZWZpbmVkIDogX29mZnNldCxcbiAgICAgICAgICAgIHJpZ2h0OiBpc1J0bCA/IF9vZmZzZXQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0b3A6IGdldFJvd09mZnNldChfdGhpcy5wcm9wcywgcm93SW5kZXgsIF90aGlzLl9pbnN0YW5jZVByb3BzKSxcbiAgICAgICAgICAgIGhlaWdodDogZ2V0Um93SGVpZ2h0KF90aGlzLnByb3BzLCByb3dJbmRleCwgX3RoaXMuX2luc3RhbmNlUHJvcHMpLFxuICAgICAgICAgICAgd2lkdGg6IGdldENvbHVtbldpZHRoKF90aGlzLnByb3BzLCBjb2x1bW5JbmRleCwgX3RoaXMuX2luc3RhbmNlUHJvcHMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLl9nZXRJdGVtU3R5bGVDYWNoZSA9IHZvaWQgMDtcbiAgICAgIF90aGlzLl9nZXRJdGVtU3R5bGVDYWNoZSA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKF8sIF9fLCBfX18pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLl9vblNjcm9sbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2V2ZW50JGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0ID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgY2xpZW50V2lkdGggPSBfZXZlbnQkY3VycmVudFRhcmdldC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSBfZXZlbnQkY3VycmVudFRhcmdldC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc2Nyb2xsVG9wID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsV2lkdGggPSBfZXZlbnQkY3VycmVudFRhcmdldC5zY3JvbGxXaWR0aDtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgaWYgKHByZXZTdGF0ZS5zY3JvbGxMZWZ0ID09PSBzY3JvbGxMZWZ0ICYmIHByZXZTdGF0ZS5zY3JvbGxUb3AgPT09IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIHBvc2l0aW9uIG1heSBoYXZlIGJlZW4gdXBkYXRlZCBieSBjRE0vY0RVLFxuICAgICAgICAgICAgLy8gSW4gd2hpY2ggY2FzZSB3ZSBkb24ndCBuZWVkIHRvIHRyaWdnZXIgYW5vdGhlciByZW5kZXIsXG4gICAgICAgICAgICAvLyBBbmQgd2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgc3RhdGUuaXNTY3JvbGxpbmcuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gX3RoaXMucHJvcHMuZGlyZWN0aW9uOyAvLyBUUklDS1kgQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzY3JvbGxMZWZ0IHNob3VsZCBiZSBuZWdhdGl2ZSBmb3IgUlRMIGFsaWduZWQgZWxlbWVudHMuXG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgdGhlIGNhc2UgZm9yIGFsbCBicm93c2VycyB0aG91Z2ggKGUuZy4gQ2hyb21lIHJlcG9ydHMgdmFsdWVzIGFzIHBvc2l0aXZlLCBtZWFzdXJlZCByZWxhdGl2ZSB0byB0aGUgbGVmdCkuXG4gICAgICAgICAgLy8gSXQncyBhbHNvIGVhc2llciBmb3IgdGhpcyBjb21wb25lbnQgaWYgd2UgY29udmVydCBvZmZzZXRzIHRvIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGV5IHdvdWxkIGJlIGluIGZvciBsdHIuXG4gICAgICAgICAgLy8gU28gdGhlIHNpbXBsZXN0IHNvbHV0aW9uIGlzIHRvIGRldGVybWluZSB3aGljaCBicm93c2VyIGJlaGF2aW9yIHdlJ3JlIGRlYWxpbmcgd2l0aCwgYW5kIGNvbnZlcnQgYmFzZWQgb24gaXQuXG5cbiAgICAgICAgICB2YXIgY2FsY3VsYXRlZFNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZ2V0UlRMT2Zmc2V0VHlwZSgpKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ25lZ2F0aXZlJzpcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkU2Nyb2xsTGVmdCA9IC1zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ3Bvc2l0aXZlLWRlc2NlbmRpbmcnOlxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRTY3JvbGxMZWZ0ID0gc2Nyb2xsV2lkdGggLSBjbGllbnRXaWR0aCAtIHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBQcmV2ZW50IFNhZmFyaSdzIGVsYXN0aWMgc2Nyb2xsaW5nIGZyb20gY2F1c2luZyB2aXN1YWwgc2hha2luZyB3aGVuIHNjcm9sbGluZyBwYXN0IGJvdW5kcy5cblxuXG4gICAgICAgICAgY2FsY3VsYXRlZFNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjYWxjdWxhdGVkU2Nyb2xsTGVmdCwgc2Nyb2xsV2lkdGggLSBjbGllbnRXaWR0aCkpO1xuICAgICAgICAgIHZhciBjYWxjdWxhdGVkU2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHRydWUsXG4gICAgICAgICAgICBob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uOiBwcmV2U3RhdGUuc2Nyb2xsTGVmdCA8IHNjcm9sbExlZnQgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdDogY2FsY3VsYXRlZFNjcm9sbExlZnQsXG4gICAgICAgICAgICBzY3JvbGxUb3A6IGNhbGN1bGF0ZWRTY3JvbGxUb3AsXG4gICAgICAgICAgICB2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbjogcHJldlN0YXRlLnNjcm9sbFRvcCA8IHNjcm9sbFRvcCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCcsXG4gICAgICAgICAgICBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdEZWJvdW5jZWQpO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuX291dGVyUmVmU2V0dGVyID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgb3V0ZXJSZWYgPSBfdGhpcy5wcm9wcy5vdXRlclJlZjtcbiAgICAgICAgX3RoaXMuX291dGVyUmVmID0gcmVmO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3V0ZXJSZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvdXRlclJlZihyZWYpO1xuICAgICAgICB9IGVsc2UgaWYgKG91dGVyUmVmICE9IG51bGwgJiYgdHlwZW9mIG91dGVyUmVmID09PSAnb2JqZWN0JyAmJiBvdXRlclJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgb3V0ZXJSZWYuY3VycmVudCA9IHJlZjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdEZWJvdW5jZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ1RpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNhbmNlbFRpbWVvdXQoX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdUaW1lb3V0SWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdUaW1lb3V0SWQgPSByZXF1ZXN0VGltZW91dChfdGhpcy5fcmVzZXRJc1Njcm9sbGluZywgSVNfU0NST0xMSU5HX0RFQk9VTkNFX0lOVEVSVkFMKTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLl9yZXNldElzU2Nyb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ1RpbWVvdXRJZCA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGlzU2Nyb2xsaW5nOiBmYWxzZVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gQ2xlYXIgc3R5bGUgY2FjaGUgYWZ0ZXIgc3RhdGUgdXBkYXRlIGhhcyBiZWVuIGNvbW1pdHRlZC5cbiAgICAgICAgICAvLyBUaGlzIHdheSB3ZSBkb24ndCBicmVhayBwdXJlIHNDVSBmb3IgaXRlbXMgdGhhdCBkb24ndCB1c2UgaXNTY3JvbGxpbmcgcGFyYW0uXG4gICAgICAgICAgX3RoaXMuX2dldEl0ZW1TdHlsZUNhY2hlKC0xKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgR3JpZC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHZhbGlkYXRlU2hhcmVkUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgdmFsaWRhdGVQcm9wcyhuZXh0UHJvcHMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBfcHJvdG8gPSBHcmlkLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5zY3JvbGxUbyA9IGZ1bmN0aW9uIHNjcm9sbFRvKF9yZWYzKSB7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IF9yZWYzLnNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsVG9wID0gX3JlZjMuc2Nyb2xsVG9wO1xuXG4gICAgICBpZiAoc2Nyb2xsTGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBzY3JvbGxMZWZ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcm9sbFRvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNjcm9sbFRvcCA9IE1hdGgubWF4KDAsIHNjcm9sbFRvcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgICBpZiAoc2Nyb2xsTGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2Nyb2xsTGVmdCA9IHByZXZTdGF0ZS5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbFRvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2Nyb2xsVG9wID0gcHJldlN0YXRlLnNjcm9sbFRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2U3RhdGUuc2Nyb2xsTGVmdCA9PT0gc2Nyb2xsTGVmdCAmJiBwcmV2U3RhdGUuc2Nyb2xsVG9wID09PSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbjogcHJldlN0YXRlLnNjcm9sbExlZnQgPCBzY3JvbGxMZWZ0ID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJyxcbiAgICAgICAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wLFxuICAgICAgICAgIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDogdHJ1ZSxcbiAgICAgICAgICB2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbjogcHJldlN0YXRlLnNjcm9sbFRvcCA8IHNjcm9sbFRvcCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCdcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMuX3Jlc2V0SXNTY3JvbGxpbmdEZWJvdW5jZWQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc2Nyb2xsVG9JdGVtID0gZnVuY3Rpb24gc2Nyb2xsVG9JdGVtKF9yZWY0KSB7XG4gICAgICB2YXIgX3JlZjQkYWxpZ24gPSBfcmVmNC5hbGlnbixcbiAgICAgICAgICBhbGlnbiA9IF9yZWY0JGFsaWduID09PSB2b2lkIDAgPyAnYXV0bycgOiBfcmVmNCRhbGlnbixcbiAgICAgICAgICBjb2x1bW5JbmRleCA9IF9yZWY0LmNvbHVtbkluZGV4LFxuICAgICAgICAgIHJvd0luZGV4ID0gX3JlZjQucm93SW5kZXg7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb2x1bW5Db3VudCA9IF90aGlzJHByb3BzMi5jb2x1bW5Db3VudCxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczIuaGVpZ2h0LFxuICAgICAgICAgIHJvd0NvdW50ID0gX3RoaXMkcHJvcHMyLnJvd0NvdW50LFxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHMyLndpZHRoO1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBzY3JvbGxMZWZ0ID0gX3RoaXMkc3RhdGUuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBzY3JvbGxUb3AgPSBfdGhpcyRzdGF0ZS5zY3JvbGxUb3A7XG4gICAgICB2YXIgc2Nyb2xsYmFyU2l6ZSA9IGdldFNjcm9sbGJhclNpemUoKTtcblxuICAgICAgaWYgKGNvbHVtbkluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sdW1uSW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2x1bW5JbmRleCwgY29sdW1uQ291bnQgLSAxKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb3dJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvd0luZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocm93SW5kZXgsIHJvd0NvdW50IC0gMSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXN0aW1hdGVkVG90YWxIZWlnaHQgPSBnZXRFc3RpbWF0ZWRUb3RhbEhlaWdodCh0aGlzLnByb3BzLCB0aGlzLl9pbnN0YW5jZVByb3BzKTtcbiAgICAgIHZhciBlc3RpbWF0ZWRUb3RhbFdpZHRoID0gZ2V0RXN0aW1hdGVkVG90YWxXaWR0aCh0aGlzLnByb3BzLCB0aGlzLl9pbnN0YW5jZVByb3BzKTsgLy8gVGhlIHNjcm9sbGJhciBzaXplIHNob3VsZCBiZSBjb25zaWRlcmVkIHdoZW4gc2Nyb2xsaW5nIGFuIGl0ZW0gaW50byB2aWV3LFxuICAgICAgLy8gdG8gZW5zdXJlIGl0J3MgZnVsbHkgdmlzaWJsZS5cbiAgICAgIC8vIEJ1dCB3ZSBvbmx5IG5lZWQgdG8gYWNjb3VudCBmb3IgaXRzIHNpemUgd2hlbiBpdCdzIGFjdHVhbGx5IHZpc2libGUuXG5cbiAgICAgIHZhciBob3Jpem9udGFsU2Nyb2xsYmFyU2l6ZSA9IGVzdGltYXRlZFRvdGFsV2lkdGggPiB3aWR0aCA/IHNjcm9sbGJhclNpemUgOiAwO1xuICAgICAgdmFyIHZlcnRpY2FsU2Nyb2xsYmFyU2l6ZSA9IGVzdGltYXRlZFRvdGFsSGVpZ2h0ID4gaGVpZ2h0ID8gc2Nyb2xsYmFyU2l6ZSA6IDA7XG4gICAgICB0aGlzLnNjcm9sbFRvKHtcbiAgICAgICAgc2Nyb2xsTGVmdDogY29sdW1uSW5kZXggIT09IHVuZGVmaW5lZCA/IGdldE9mZnNldEZvckNvbHVtbkFuZEFsaWdubWVudCh0aGlzLnByb3BzLCBjb2x1bW5JbmRleCwgYWxpZ24sIHNjcm9sbExlZnQsIHRoaXMuX2luc3RhbmNlUHJvcHMsIHZlcnRpY2FsU2Nyb2xsYmFyU2l6ZSkgOiBzY3JvbGxMZWZ0LFxuICAgICAgICBzY3JvbGxUb3A6IHJvd0luZGV4ICE9PSB1bmRlZmluZWQgPyBnZXRPZmZzZXRGb3JSb3dBbmRBbGlnbm1lbnQodGhpcy5wcm9wcywgcm93SW5kZXgsIGFsaWduLCBzY3JvbGxUb3AsIHRoaXMuX2luc3RhbmNlUHJvcHMsIGhvcml6b250YWxTY3JvbGxiYXJTaXplKSA6IHNjcm9sbFRvcFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgaW5pdGlhbFNjcm9sbExlZnQgPSBfdGhpcyRwcm9wczMuaW5pdGlhbFNjcm9sbExlZnQsXG4gICAgICAgICAgaW5pdGlhbFNjcm9sbFRvcCA9IF90aGlzJHByb3BzMy5pbml0aWFsU2Nyb2xsVG9wO1xuXG4gICAgICBpZiAodGhpcy5fb3V0ZXJSZWYgIT0gbnVsbCkge1xuICAgICAgICB2YXIgb3V0ZXJSZWYgPSB0aGlzLl9vdXRlclJlZjtcblxuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxTY3JvbGxMZWZ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG91dGVyUmVmLnNjcm9sbExlZnQgPSBpbml0aWFsU2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFNjcm9sbFRvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvdXRlclJlZi5zY3JvbGxUb3AgPSBpbml0aWFsU2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhbGxQcm9wc0NhbGxiYWNrcygpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMucHJvcHMuZGlyZWN0aW9uO1xuICAgICAgdmFyIF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgc2Nyb2xsTGVmdCA9IF90aGlzJHN0YXRlMi5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF90aGlzJHN0YXRlMi5zY3JvbGxUb3AsXG4gICAgICAgICAgc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkID0gX3RoaXMkc3RhdGUyLnNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDtcblxuICAgICAgaWYgKHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCAmJiB0aGlzLl9vdXRlclJlZiAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRSSUNLWSBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNjcm9sbExlZnQgc2hvdWxkIGJlIG5lZ2F0aXZlIGZvciBSVEwgYWxpZ25lZCBlbGVtZW50cy5cbiAgICAgICAgLy8gVGhpcyBpcyBub3QgdGhlIGNhc2UgZm9yIGFsbCBicm93c2VycyB0aG91Z2ggKGUuZy4gQ2hyb21lIHJlcG9ydHMgdmFsdWVzIGFzIHBvc2l0aXZlLCBtZWFzdXJlZCByZWxhdGl2ZSB0byB0aGUgbGVmdCkuXG4gICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGJyb3dzZXIgYmVoYXZpb3Igd2UncmUgZGVhbGluZyB3aXRoLCBhbmQgbWltaWMgaXQuXG4gICAgICAgIHZhciBvdXRlclJlZiA9IHRoaXMuX291dGVyUmVmO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgc3dpdGNoIChnZXRSVExPZmZzZXRUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ25lZ2F0aXZlJzpcbiAgICAgICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsTGVmdCA9IC1zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncG9zaXRpdmUtYXNjZW5kaW5nJzpcbiAgICAgICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB2YXIgY2xpZW50V2lkdGggPSBvdXRlclJlZi5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHNjcm9sbFdpZHRoID0gb3V0ZXJSZWYuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICAgIG91dGVyUmVmLnNjcm9sbExlZnQgPSBzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoIC0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dGVyUmVmLnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBzY3JvbGxMZWZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dGVyUmVmLnNjcm9sbFRvcCA9IE1hdGgubWF4KDAsIHNjcm9sbFRvcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhbGxQcm9wc0NhbGxiYWNrcygpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQodGhpcy5fcmVzZXRJc1Njcm9sbGluZ1RpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNC5jaGlsZHJlbixcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczQuY2xhc3NOYW1lLFxuICAgICAgICAgIGNvbHVtbkNvdW50ID0gX3RoaXMkcHJvcHM0LmNvbHVtbkNvdW50LFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF90aGlzJHByb3BzNC5kaXJlY3Rpb24sXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM0LmhlaWdodCxcbiAgICAgICAgICBpbm5lclJlZiA9IF90aGlzJHByb3BzNC5pbm5lclJlZixcbiAgICAgICAgICBpbm5lckVsZW1lbnRUeXBlID0gX3RoaXMkcHJvcHM0LmlubmVyRWxlbWVudFR5cGUsXG4gICAgICAgICAgaW5uZXJUYWdOYW1lID0gX3RoaXMkcHJvcHM0LmlubmVyVGFnTmFtZSxcbiAgICAgICAgICBpdGVtRGF0YSA9IF90aGlzJHByb3BzNC5pdGVtRGF0YSxcbiAgICAgICAgICBfdGhpcyRwcm9wczQkaXRlbUtleSA9IF90aGlzJHByb3BzNC5pdGVtS2V5LFxuICAgICAgICAgIGl0ZW1LZXkgPSBfdGhpcyRwcm9wczQkaXRlbUtleSA9PT0gdm9pZCAwID8gZGVmYXVsdEl0ZW1LZXkgOiBfdGhpcyRwcm9wczQkaXRlbUtleSxcbiAgICAgICAgICBvdXRlckVsZW1lbnRUeXBlID0gX3RoaXMkcHJvcHM0Lm91dGVyRWxlbWVudFR5cGUsXG4gICAgICAgICAgb3V0ZXJUYWdOYW1lID0gX3RoaXMkcHJvcHM0Lm91dGVyVGFnTmFtZSxcbiAgICAgICAgICByb3dDb3VudCA9IF90aGlzJHByb3BzNC5yb3dDb3VudCxcbiAgICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzNC5zdHlsZSxcbiAgICAgICAgICB1c2VJc1Njcm9sbGluZyA9IF90aGlzJHByb3BzNC51c2VJc1Njcm9sbGluZyxcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNC53aWR0aDtcbiAgICAgIHZhciBpc1Njcm9sbGluZyA9IHRoaXMuc3RhdGUuaXNTY3JvbGxpbmc7XG5cbiAgICAgIHZhciBfdGhpcyRfZ2V0SG9yaXpvbnRhbFIgPSB0aGlzLl9nZXRIb3Jpem9udGFsUmFuZ2VUb1JlbmRlcigpLFxuICAgICAgICAgIGNvbHVtblN0YXJ0SW5kZXggPSBfdGhpcyRfZ2V0SG9yaXpvbnRhbFJbMF0sXG4gICAgICAgICAgY29sdW1uU3RvcEluZGV4ID0gX3RoaXMkX2dldEhvcml6b250YWxSWzFdO1xuXG4gICAgICB2YXIgX3RoaXMkX2dldFZlcnRpY2FsUmFuID0gdGhpcy5fZ2V0VmVydGljYWxSYW5nZVRvUmVuZGVyKCksXG4gICAgICAgICAgcm93U3RhcnRJbmRleCA9IF90aGlzJF9nZXRWZXJ0aWNhbFJhblswXSxcbiAgICAgICAgICByb3dTdG9wSW5kZXggPSBfdGhpcyRfZ2V0VmVydGljYWxSYW5bMV07XG5cbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgICBpZiAoY29sdW1uQ291bnQgPiAwICYmIHJvd0NvdW50KSB7XG4gICAgICAgIGZvciAodmFyIF9yb3dJbmRleCA9IHJvd1N0YXJ0SW5kZXg7IF9yb3dJbmRleCA8PSByb3dTdG9wSW5kZXg7IF9yb3dJbmRleCsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2NvbHVtbkluZGV4ID0gY29sdW1uU3RhcnRJbmRleDsgX2NvbHVtbkluZGV4IDw9IGNvbHVtblN0b3BJbmRleDsgX2NvbHVtbkluZGV4KyspIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goY3JlYXRlRWxlbWVudChjaGlsZHJlbiwge1xuICAgICAgICAgICAgICBjb2x1bW5JbmRleDogX2NvbHVtbkluZGV4LFxuICAgICAgICAgICAgICBkYXRhOiBpdGVtRGF0YSxcbiAgICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHVzZUlzU2Nyb2xsaW5nID8gaXNTY3JvbGxpbmcgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGtleTogaXRlbUtleSh7XG4gICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IF9jb2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhOiBpdGVtRGF0YSxcbiAgICAgICAgICAgICAgICByb3dJbmRleDogX3Jvd0luZGV4XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICByb3dJbmRleDogX3Jvd0luZGV4LFxuICAgICAgICAgICAgICBzdHlsZTogdGhpcy5fZ2V0SXRlbVN0eWxlKF9yb3dJbmRleCwgX2NvbHVtbkluZGV4KVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBSZWFkIHRoaXMgdmFsdWUgQUZURVIgaXRlbXMgaGF2ZSBiZWVuIGNyZWF0ZWQsXG4gICAgICAvLyBTbyB0aGVpciBhY3R1YWwgc2l6ZXMgKGlmIHZhcmlhYmxlKSBhcmUgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uLlxuXG5cbiAgICAgIHZhciBlc3RpbWF0ZWRUb3RhbEhlaWdodCA9IGdldEVzdGltYXRlZFRvdGFsSGVpZ2h0KHRoaXMucHJvcHMsIHRoaXMuX2luc3RhbmNlUHJvcHMpO1xuICAgICAgdmFyIGVzdGltYXRlZFRvdGFsV2lkdGggPSBnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoKHRoaXMucHJvcHMsIHRoaXMuX2luc3RhbmNlUHJvcHMpO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQob3V0ZXJFbGVtZW50VHlwZSB8fCBvdXRlclRhZ05hbWUgfHwgJ2RpdicsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIG9uU2Nyb2xsOiB0aGlzLl9vblNjcm9sbCxcbiAgICAgICAgcmVmOiB0aGlzLl9vdXRlclJlZlNldHRlcixcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgICAgICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJyxcbiAgICAgICAgICB3aWxsQ2hhbmdlOiAndHJhbnNmb3JtJyxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9LCBzdHlsZSlcbiAgICAgIH0sIGNyZWF0ZUVsZW1lbnQoaW5uZXJFbGVtZW50VHlwZSB8fCBpbm5lclRhZ05hbWUgfHwgJ2RpdicsIHtcbiAgICAgICAgY2hpbGRyZW46IGl0ZW1zLFxuICAgICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGhlaWdodDogZXN0aW1hdGVkVG90YWxIZWlnaHQsXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogaXNTY3JvbGxpbmcgPyAnbm9uZScgOiB1bmRlZmluZWQsXG4gICAgICAgICAgd2lkdGg6IGVzdGltYXRlZFRvdGFsV2lkdGhcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2NhbGxQcm9wc0NhbGxiYWNrcyA9IGZ1bmN0aW9uIF9jYWxsUHJvcHNDYWxsYmFja3MoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb2x1bW5Db3VudCA9IF90aGlzJHByb3BzNS5jb2x1bW5Db3VudCxcbiAgICAgICAgICBvbkl0ZW1zUmVuZGVyZWQgPSBfdGhpcyRwcm9wczUub25JdGVtc1JlbmRlcmVkLFxuICAgICAgICAgIG9uU2Nyb2xsID0gX3RoaXMkcHJvcHM1Lm9uU2Nyb2xsLFxuICAgICAgICAgIHJvd0NvdW50ID0gX3RoaXMkcHJvcHM1LnJvd0NvdW50O1xuXG4gICAgICBpZiAodHlwZW9mIG9uSXRlbXNSZW5kZXJlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoY29sdW1uQ291bnQgPiAwICYmIHJvd0NvdW50ID4gMCkge1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0SG9yaXpvbnRhbFIyID0gdGhpcy5fZ2V0SG9yaXpvbnRhbFJhbmdlVG9SZW5kZXIoKSxcbiAgICAgICAgICAgICAgX292ZXJzY2FuQ29sdW1uU3RhcnRJbmRleCA9IF90aGlzJF9nZXRIb3Jpem9udGFsUjJbMF0sXG4gICAgICAgICAgICAgIF9vdmVyc2NhbkNvbHVtblN0b3BJbmRleCA9IF90aGlzJF9nZXRIb3Jpem9udGFsUjJbMV0sXG4gICAgICAgICAgICAgIF92aXNpYmxlQ29sdW1uU3RhcnRJbmRleCA9IF90aGlzJF9nZXRIb3Jpem9udGFsUjJbMl0sXG4gICAgICAgICAgICAgIF92aXNpYmxlQ29sdW1uU3RvcEluZGV4ID0gX3RoaXMkX2dldEhvcml6b250YWxSMlszXTtcblxuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0VmVydGljYWxSYW4yID0gdGhpcy5fZ2V0VmVydGljYWxSYW5nZVRvUmVuZGVyKCksXG4gICAgICAgICAgICAgIF9vdmVyc2NhblJvd1N0YXJ0SW5kZXggPSBfdGhpcyRfZ2V0VmVydGljYWxSYW4yWzBdLFxuICAgICAgICAgICAgICBfb3ZlcnNjYW5Sb3dTdG9wSW5kZXggPSBfdGhpcyRfZ2V0VmVydGljYWxSYW4yWzFdLFxuICAgICAgICAgICAgICBfdmlzaWJsZVJvd1N0YXJ0SW5kZXggPSBfdGhpcyRfZ2V0VmVydGljYWxSYW4yWzJdLFxuICAgICAgICAgICAgICBfdmlzaWJsZVJvd1N0b3BJbmRleCA9IF90aGlzJF9nZXRWZXJ0aWNhbFJhbjJbM107XG5cbiAgICAgICAgICB0aGlzLl9jYWxsT25JdGVtc1JlbmRlcmVkKF9vdmVyc2NhbkNvbHVtblN0YXJ0SW5kZXgsIF9vdmVyc2NhbkNvbHVtblN0b3BJbmRleCwgX292ZXJzY2FuUm93U3RhcnRJbmRleCwgX292ZXJzY2FuUm93U3RvcEluZGV4LCBfdmlzaWJsZUNvbHVtblN0YXJ0SW5kZXgsIF92aXNpYmxlQ29sdW1uU3RvcEluZGV4LCBfdmlzaWJsZVJvd1N0YXJ0SW5kZXgsIF92aXNpYmxlUm93U3RvcEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9uU2Nyb2xsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTMgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgX2hvcml6b250YWxTY3JvbGxEaXJlY3Rpb24gPSBfdGhpcyRzdGF0ZTMuaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbixcbiAgICAgICAgICAgIF9zY3JvbGxMZWZ0ID0gX3RoaXMkc3RhdGUzLnNjcm9sbExlZnQsXG4gICAgICAgICAgICBfc2Nyb2xsVG9wID0gX3RoaXMkc3RhdGUzLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIF9zY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQgPSBfdGhpcyRzdGF0ZTMuc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkLFxuICAgICAgICAgICAgX3ZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uID0gX3RoaXMkc3RhdGUzLnZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uO1xuXG4gICAgICAgIHRoaXMuX2NhbGxPblNjcm9sbChfc2Nyb2xsTGVmdCwgX3Njcm9sbFRvcCwgX2hvcml6b250YWxTY3JvbGxEaXJlY3Rpb24sIF92ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbiwgX3Njcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCk7XG4gICAgICB9XG4gICAgfSAvLyBMYXppbHkgY3JlYXRlIGFuZCBjYWNoZSBpdGVtIHN0eWxlcyB3aGlsZSBzY3JvbGxpbmcsXG4gICAgLy8gU28gdGhhdCBwdXJlIGNvbXBvbmVudCBzQ1Ugd2lsbCBwcmV2ZW50IHJlLXJlbmRlcnMuXG4gICAgLy8gV2UgbWFpbnRhaW4gdGhpcyBjYWNoZSwgYW5kIHBhc3MgYSBzdHlsZSBwcm9wIHJhdGhlciB0aGFuIGluZGV4LFxuICAgIC8vIFNvIHRoYXQgTGlzdCBjYW4gY2xlYXIgY2FjaGVkIHN0eWxlcyBhbmQgZm9yY2UgaXRlbSByZS1yZW5kZXIgaWYgbmVjZXNzYXJ5LlxuICAgIDtcblxuICAgIF9wcm90by5fZ2V0SG9yaXpvbnRhbFJhbmdlVG9SZW5kZXIgPSBmdW5jdGlvbiBfZ2V0SG9yaXpvbnRhbFJhbmdlVG9SZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb2x1bW5Db3VudCA9IF90aGlzJHByb3BzNi5jb2x1bW5Db3VudCxcbiAgICAgICAgICBvdmVyc2NhbkNvbHVtbkNvdW50ID0gX3RoaXMkcHJvcHM2Lm92ZXJzY2FuQ29sdW1uQ291bnQsXG4gICAgICAgICAgb3ZlcnNjYW5Db2x1bW5zQ291bnQgPSBfdGhpcyRwcm9wczYub3ZlcnNjYW5Db2x1bW5zQ291bnQsXG4gICAgICAgICAgb3ZlcnNjYW5Db3VudCA9IF90aGlzJHByb3BzNi5vdmVyc2NhbkNvdW50LFxuICAgICAgICAgIHJvd0NvdW50ID0gX3RoaXMkcHJvcHM2LnJvd0NvdW50O1xuICAgICAgdmFyIF90aGlzJHN0YXRlNCA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiA9IF90aGlzJHN0YXRlNC5ob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uLFxuICAgICAgICAgIGlzU2Nyb2xsaW5nID0gX3RoaXMkc3RhdGU0LmlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHNjcm9sbExlZnQgPSBfdGhpcyRzdGF0ZTQuc2Nyb2xsTGVmdDtcbiAgICAgIHZhciBvdmVyc2NhbkNvdW50UmVzb2x2ZWQgPSBvdmVyc2NhbkNvbHVtbkNvdW50IHx8IG92ZXJzY2FuQ29sdW1uc0NvdW50IHx8IG92ZXJzY2FuQ291bnQgfHwgMTtcblxuICAgICAgaWYgKGNvbHVtbkNvdW50ID09PSAwIHx8IHJvd0NvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEluZGV4ID0gZ2V0Q29sdW1uU3RhcnRJbmRleEZvck9mZnNldCh0aGlzLnByb3BzLCBzY3JvbGxMZWZ0LCB0aGlzLl9pbnN0YW5jZVByb3BzKTtcbiAgICAgIHZhciBzdG9wSW5kZXggPSBnZXRDb2x1bW5TdG9wSW5kZXhGb3JTdGFydEluZGV4KHRoaXMucHJvcHMsIHN0YXJ0SW5kZXgsIHNjcm9sbExlZnQsIHRoaXMuX2luc3RhbmNlUHJvcHMpOyAvLyBPdmVyc2NhbiBieSBvbmUgaXRlbSBpbiBlYWNoIGRpcmVjdGlvbiBzbyB0aGF0IHRhYi9mb2N1cyB3b3Jrcy5cbiAgICAgIC8vIElmIHRoZXJlIGlzbid0IGF0IGxlYXN0IG9uZSBleHRyYSBpdGVtLCB0YWIgbG9vcHMgYmFjayBhcm91bmQuXG5cbiAgICAgIHZhciBvdmVyc2NhbkJhY2t3YXJkID0gIWlzU2Nyb2xsaW5nIHx8IGhvcml6b250YWxTY3JvbGxEaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyBNYXRoLm1heCgxLCBvdmVyc2NhbkNvdW50UmVzb2x2ZWQpIDogMTtcbiAgICAgIHZhciBvdmVyc2NhbkZvcndhcmQgPSAhaXNTY3JvbGxpbmcgfHwgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gTWF0aC5tYXgoMSwgb3ZlcnNjYW5Db3VudFJlc29sdmVkKSA6IDE7XG4gICAgICByZXR1cm4gW01hdGgubWF4KDAsIHN0YXJ0SW5kZXggLSBvdmVyc2NhbkJhY2t3YXJkKSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oY29sdW1uQ291bnQgLSAxLCBzdG9wSW5kZXggKyBvdmVyc2NhbkZvcndhcmQpKSwgc3RhcnRJbmRleCwgc3RvcEluZGV4XTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9nZXRWZXJ0aWNhbFJhbmdlVG9SZW5kZXIgPSBmdW5jdGlvbiBfZ2V0VmVydGljYWxSYW5nZVRvUmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY29sdW1uQ291bnQgPSBfdGhpcyRwcm9wczcuY29sdW1uQ291bnQsXG4gICAgICAgICAgb3ZlcnNjYW5Db3VudCA9IF90aGlzJHByb3BzNy5vdmVyc2NhbkNvdW50LFxuICAgICAgICAgIG92ZXJzY2FuUm93Q291bnQgPSBfdGhpcyRwcm9wczcub3ZlcnNjYW5Sb3dDb3VudCxcbiAgICAgICAgICBvdmVyc2NhblJvd3NDb3VudCA9IF90aGlzJHByb3BzNy5vdmVyc2NhblJvd3NDb3VudCxcbiAgICAgICAgICByb3dDb3VudCA9IF90aGlzJHByb3BzNy5yb3dDb3VudDtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIGlzU2Nyb2xsaW5nID0gX3RoaXMkc3RhdGU1LmlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uID0gX3RoaXMkc3RhdGU1LnZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uLFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF90aGlzJHN0YXRlNS5zY3JvbGxUb3A7XG4gICAgICB2YXIgb3ZlcnNjYW5Db3VudFJlc29sdmVkID0gb3ZlcnNjYW5Sb3dDb3VudCB8fCBvdmVyc2NhblJvd3NDb3VudCB8fCBvdmVyc2NhbkNvdW50IHx8IDE7XG5cbiAgICAgIGlmIChjb2x1bW5Db3VudCA9PT0gMCB8fCByb3dDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRJbmRleCA9IGdldFJvd1N0YXJ0SW5kZXhGb3JPZmZzZXQodGhpcy5wcm9wcywgc2Nyb2xsVG9wLCB0aGlzLl9pbnN0YW5jZVByb3BzKTtcbiAgICAgIHZhciBzdG9wSW5kZXggPSBnZXRSb3dTdG9wSW5kZXhGb3JTdGFydEluZGV4KHRoaXMucHJvcHMsIHN0YXJ0SW5kZXgsIHNjcm9sbFRvcCwgdGhpcy5faW5zdGFuY2VQcm9wcyk7IC8vIE92ZXJzY2FuIGJ5IG9uZSBpdGVtIGluIGVhY2ggZGlyZWN0aW9uIHNvIHRoYXQgdGFiL2ZvY3VzIHdvcmtzLlxuICAgICAgLy8gSWYgdGhlcmUgaXNuJ3QgYXQgbGVhc3Qgb25lIGV4dHJhIGl0ZW0sIHRhYiBsb29wcyBiYWNrIGFyb3VuZC5cblxuICAgICAgdmFyIG92ZXJzY2FuQmFja3dhcmQgPSAhaXNTY3JvbGxpbmcgfHwgdmVydGljYWxTY3JvbGxEaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyBNYXRoLm1heCgxLCBvdmVyc2NhbkNvdW50UmVzb2x2ZWQpIDogMTtcbiAgICAgIHZhciBvdmVyc2NhbkZvcndhcmQgPSAhaXNTY3JvbGxpbmcgfHwgdmVydGljYWxTY3JvbGxEaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IE1hdGgubWF4KDEsIG92ZXJzY2FuQ291bnRSZXNvbHZlZCkgOiAxO1xuICAgICAgcmV0dXJuIFtNYXRoLm1heCgwLCBzdGFydEluZGV4IC0gb3ZlcnNjYW5CYWNrd2FyZCksIE1hdGgubWF4KDAsIE1hdGgubWluKHJvd0NvdW50IC0gMSwgc3RvcEluZGV4ICsgb3ZlcnNjYW5Gb3J3YXJkKSksIHN0YXJ0SW5kZXgsIHN0b3BJbmRleF07XG4gICAgfTtcblxuICAgIHJldHVybiBHcmlkO1xuICB9KFB1cmVDb21wb25lbnQpLCBfY2xhc3MuZGVmYXVsdFByb3BzID0ge1xuICAgIGRpcmVjdGlvbjogJ2x0cicsXG4gICAgaXRlbURhdGE6IHVuZGVmaW5lZCxcbiAgICB1c2VJc1Njcm9sbGluZzogZmFsc2VcbiAgfSwgX2NsYXNzO1xufVxuXG52YXIgdmFsaWRhdGVTaGFyZWRQcm9wcyA9IGZ1bmN0aW9uIHZhbGlkYXRlU2hhcmVkUHJvcHMoX3JlZjUsIF9yZWY2KSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWY1LmNoaWxkcmVuLFxuICAgICAgZGlyZWN0aW9uID0gX3JlZjUuZGlyZWN0aW9uLFxuICAgICAgaGVpZ2h0ID0gX3JlZjUuaGVpZ2h0LFxuICAgICAgaW5uZXJUYWdOYW1lID0gX3JlZjUuaW5uZXJUYWdOYW1lLFxuICAgICAgb3V0ZXJUYWdOYW1lID0gX3JlZjUub3V0ZXJUYWdOYW1lLFxuICAgICAgb3ZlcnNjYW5Db2x1bW5zQ291bnQgPSBfcmVmNS5vdmVyc2NhbkNvbHVtbnNDb3VudCxcbiAgICAgIG92ZXJzY2FuQ291bnQgPSBfcmVmNS5vdmVyc2NhbkNvdW50LFxuICAgICAgb3ZlcnNjYW5Sb3dzQ291bnQgPSBfcmVmNS5vdmVyc2NhblJvd3NDb3VudCxcbiAgICAgIHdpZHRoID0gX3JlZjUud2lkdGg7XG4gIHZhciBpbnN0YW5jZSA9IF9yZWY2Lmluc3RhbmNlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBvdmVyc2NhbkNvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGRldldhcm5pbmdzT3ZlcnNjYW5Db3VudCAmJiAhZGV2V2FybmluZ3NPdmVyc2NhbkNvdW50LmhhcyhpbnN0YW5jZSkpIHtcbiAgICAgICAgZGV2V2FybmluZ3NPdmVyc2NhbkNvdW50LmFkZChpbnN0YW5jZSk7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIG92ZXJzY2FuQ291bnQgcHJvcCBoYXMgYmVlbiBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgdGhlIG92ZXJzY2FuQ29sdW1uQ291bnQgYW5kIG92ZXJzY2FuUm93Q291bnQgcHJvcHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG92ZXJzY2FuQ29sdW1uc0NvdW50ID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb3ZlcnNjYW5Sb3dzQ291bnQgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoZGV2V2FybmluZ3NPdmVyc2NhblJvd3NDb2x1bW5zQ291bnQgJiYgIWRldldhcm5pbmdzT3ZlcnNjYW5Sb3dzQ29sdW1uc0NvdW50LmhhcyhpbnN0YW5jZSkpIHtcbiAgICAgICAgZGV2V2FybmluZ3NPdmVyc2NhblJvd3NDb2x1bW5zQ291bnQuYWRkKGluc3RhbmNlKTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgb3ZlcnNjYW5Db2x1bW5zQ291bnQgYW5kIG92ZXJzY2FuUm93c0NvdW50IHByb3BzIGhhdmUgYmVlbiBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgdGhlIG92ZXJzY2FuQ29sdW1uQ291bnQgYW5kIG92ZXJzY2FuUm93Q291bnQgcHJvcHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5uZXJUYWdOYW1lICE9IG51bGwgfHwgb3V0ZXJUYWdOYW1lICE9IG51bGwpIHtcbiAgICAgIGlmIChkZXZXYXJuaW5nc1RhZ05hbWUgJiYgIWRldldhcm5pbmdzVGFnTmFtZS5oYXMoaW5zdGFuY2UpKSB7XG4gICAgICAgIGRldldhcm5pbmdzVGFnTmFtZS5hZGQoaW5zdGFuY2UpO1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBpbm5lclRhZ05hbWUgYW5kIG91dGVyVGFnTmFtZSBwcm9wcyBoYXZlIGJlZW4gZGVwcmVjYXRlZC4gJyArICdQbGVhc2UgdXNlIHRoZSBpbm5lckVsZW1lbnRUeXBlIGFuZCBvdXRlckVsZW1lbnRUeXBlIHByb3BzIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwiY2hpbGRyZW5cIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdWYWx1ZSBzaG91bGQgYmUgYSBSZWFjdCBjb21wb25lbnQuICcgKyAoXCJcXFwiXCIgKyAoY2hpbGRyZW4gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgY2hpbGRyZW4pICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAnbHRyJzpcbiAgICAgIGNhc2UgJ3J0bCc6XG4gICAgICAgIC8vIFZhbGlkIHZhbHVlc1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0FuIGludmFsaWQgXCJkaXJlY3Rpb25cIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdWYWx1ZSBzaG91bGQgYmUgZWl0aGVyIFwibHRyXCIgb3IgXCJydGxcIi4gJyArIChcIlxcXCJcIiArIGRpcmVjdGlvbiArIFwiXFxcIiB3YXMgc3BlY2lmaWVkLlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwid2lkdGhcIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdHcmlkcyBtdXN0IHNwZWNpZnkgYSBudW1iZXIgZm9yIHdpZHRoLiAnICsgKFwiXFxcIlwiICsgKHdpZHRoID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHdpZHRoKSArIFwiXFxcIiB3YXMgc3BlY2lmaWVkLlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBFcnJvcignQW4gaW52YWxpZCBcImhlaWdodFwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ0dyaWRzIG11c3Qgc3BlY2lmeSBhIG51bWJlciBmb3IgaGVpZ2h0LiAnICsgKFwiXFxcIlwiICsgKGhlaWdodCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBoZWlnaHQpICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX0VTVElNQVRFRF9JVEVNX1NJWkUgPSA1MDtcblxudmFyIGdldEVzdGltYXRlZFRvdGFsSGVpZ2h0ID0gZnVuY3Rpb24gZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQoX3JlZiwgX3JlZjIpIHtcbiAgdmFyIHJvd0NvdW50ID0gX3JlZi5yb3dDb3VudDtcbiAgdmFyIHJvd01ldGFkYXRhTWFwID0gX3JlZjIucm93TWV0YWRhdGFNYXAsXG4gICAgICBlc3RpbWF0ZWRSb3dIZWlnaHQgPSBfcmVmMi5lc3RpbWF0ZWRSb3dIZWlnaHQsXG4gICAgICBsYXN0TWVhc3VyZWRSb3dJbmRleCA9IF9yZWYyLmxhc3RNZWFzdXJlZFJvd0luZGV4O1xuICB2YXIgdG90YWxTaXplT2ZNZWFzdXJlZFJvd3MgPSAwOyAvLyBFZGdlIGNhc2UgY2hlY2sgZm9yIHdoZW4gdGhlIG51bWJlciBvZiBpdGVtcyBkZWNyZWFzZXMgd2hpbGUgYSBzY3JvbGwgaXMgaW4gcHJvZ3Jlc3MuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9idmF1Z2huL3JlYWN0LXdpbmRvdy9wdWxsLzEzOFxuXG4gIGlmIChsYXN0TWVhc3VyZWRSb3dJbmRleCA+PSByb3dDb3VudCkge1xuICAgIGxhc3RNZWFzdXJlZFJvd0luZGV4ID0gcm93Q291bnQgLSAxO1xuICB9XG5cbiAgaWYgKGxhc3RNZWFzdXJlZFJvd0luZGV4ID49IDApIHtcbiAgICB2YXIgaXRlbU1ldGFkYXRhID0gcm93TWV0YWRhdGFNYXBbbGFzdE1lYXN1cmVkUm93SW5kZXhdO1xuICAgIHRvdGFsU2l6ZU9mTWVhc3VyZWRSb3dzID0gaXRlbU1ldGFkYXRhLm9mZnNldCArIGl0ZW1NZXRhZGF0YS5zaXplO1xuICB9XG5cbiAgdmFyIG51bVVubWVhc3VyZWRJdGVtcyA9IHJvd0NvdW50IC0gbGFzdE1lYXN1cmVkUm93SW5kZXggLSAxO1xuICB2YXIgdG90YWxTaXplT2ZVbm1lYXN1cmVkSXRlbXMgPSBudW1Vbm1lYXN1cmVkSXRlbXMgKiBlc3RpbWF0ZWRSb3dIZWlnaHQ7XG4gIHJldHVybiB0b3RhbFNpemVPZk1lYXN1cmVkUm93cyArIHRvdGFsU2l6ZU9mVW5tZWFzdXJlZEl0ZW1zO1xufTtcblxudmFyIGdldEVzdGltYXRlZFRvdGFsV2lkdGggPSBmdW5jdGlvbiBnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoKF9yZWYzLCBfcmVmNCkge1xuICB2YXIgY29sdW1uQ291bnQgPSBfcmVmMy5jb2x1bW5Db3VudDtcbiAgdmFyIGNvbHVtbk1ldGFkYXRhTWFwID0gX3JlZjQuY29sdW1uTWV0YWRhdGFNYXAsXG4gICAgICBlc3RpbWF0ZWRDb2x1bW5XaWR0aCA9IF9yZWY0LmVzdGltYXRlZENvbHVtbldpZHRoLFxuICAgICAgbGFzdE1lYXN1cmVkQ29sdW1uSW5kZXggPSBfcmVmNC5sYXN0TWVhc3VyZWRDb2x1bW5JbmRleDtcbiAgdmFyIHRvdGFsU2l6ZU9mTWVhc3VyZWRSb3dzID0gMDsgLy8gRWRnZSBjYXNlIGNoZWNrIGZvciB3aGVuIHRoZSBudW1iZXIgb2YgaXRlbXMgZGVjcmVhc2VzIHdoaWxlIGEgc2Nyb2xsIGlzIGluIHByb2dyZXNzLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnZhdWdobi9yZWFjdC13aW5kb3cvcHVsbC8xMzhcblxuICBpZiAobGFzdE1lYXN1cmVkQ29sdW1uSW5kZXggPj0gY29sdW1uQ291bnQpIHtcbiAgICBsYXN0TWVhc3VyZWRDb2x1bW5JbmRleCA9IGNvbHVtbkNvdW50IC0gMTtcbiAgfVxuXG4gIGlmIChsYXN0TWVhc3VyZWRDb2x1bW5JbmRleCA+PSAwKSB7XG4gICAgdmFyIGl0ZW1NZXRhZGF0YSA9IGNvbHVtbk1ldGFkYXRhTWFwW2xhc3RNZWFzdXJlZENvbHVtbkluZGV4XTtcbiAgICB0b3RhbFNpemVPZk1lYXN1cmVkUm93cyA9IGl0ZW1NZXRhZGF0YS5vZmZzZXQgKyBpdGVtTWV0YWRhdGEuc2l6ZTtcbiAgfVxuXG4gIHZhciBudW1Vbm1lYXN1cmVkSXRlbXMgPSBjb2x1bW5Db3VudCAtIGxhc3RNZWFzdXJlZENvbHVtbkluZGV4IC0gMTtcbiAgdmFyIHRvdGFsU2l6ZU9mVW5tZWFzdXJlZEl0ZW1zID0gbnVtVW5tZWFzdXJlZEl0ZW1zICogZXN0aW1hdGVkQ29sdW1uV2lkdGg7XG4gIHJldHVybiB0b3RhbFNpemVPZk1lYXN1cmVkUm93cyArIHRvdGFsU2l6ZU9mVW5tZWFzdXJlZEl0ZW1zO1xufTtcblxudmFyIGdldEl0ZW1NZXRhZGF0YSA9IGZ1bmN0aW9uIGdldEl0ZW1NZXRhZGF0YShpdGVtVHlwZSwgcHJvcHMsIGluZGV4LCBpbnN0YW5jZVByb3BzKSB7XG4gIHZhciBpdGVtTWV0YWRhdGFNYXAsIGl0ZW1TaXplLCBsYXN0TWVhc3VyZWRJbmRleDtcblxuICBpZiAoaXRlbVR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgaXRlbU1ldGFkYXRhTWFwID0gaW5zdGFuY2VQcm9wcy5jb2x1bW5NZXRhZGF0YU1hcDtcbiAgICBpdGVtU2l6ZSA9IHByb3BzLmNvbHVtbldpZHRoO1xuICAgIGxhc3RNZWFzdXJlZEluZGV4ID0gaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRDb2x1bW5JbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpdGVtTWV0YWRhdGFNYXAgPSBpbnN0YW5jZVByb3BzLnJvd01ldGFkYXRhTWFwO1xuICAgIGl0ZW1TaXplID0gcHJvcHMucm93SGVpZ2h0O1xuICAgIGxhc3RNZWFzdXJlZEluZGV4ID0gaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRSb3dJbmRleDtcbiAgfVxuXG4gIGlmIChpbmRleCA+IGxhc3RNZWFzdXJlZEluZGV4KSB7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICBpZiAobGFzdE1lYXN1cmVkSW5kZXggPj0gMCkge1xuICAgICAgdmFyIGl0ZW1NZXRhZGF0YSA9IGl0ZW1NZXRhZGF0YU1hcFtsYXN0TWVhc3VyZWRJbmRleF07XG4gICAgICBvZmZzZXQgPSBpdGVtTWV0YWRhdGEub2Zmc2V0ICsgaXRlbU1ldGFkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IGxhc3RNZWFzdXJlZEluZGV4ICsgMTsgaSA8PSBpbmRleDsgaSsrKSB7XG4gICAgICB2YXIgc2l6ZSA9IGl0ZW1TaXplKGkpO1xuICAgICAgaXRlbU1ldGFkYXRhTWFwW2ldID0ge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgfTtcbiAgICAgIG9mZnNldCArPSBzaXplO1xuICAgIH1cblxuICAgIGlmIChpdGVtVHlwZSA9PT0gJ2NvbHVtbicpIHtcbiAgICAgIGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkQ29sdW1uSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRSb3dJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpdGVtTWV0YWRhdGFNYXBbaW5kZXhdO1xufTtcblxudmFyIGZpbmROZWFyZXN0SXRlbSA9IGZ1bmN0aW9uIGZpbmROZWFyZXN0SXRlbShpdGVtVHlwZSwgcHJvcHMsIGluc3RhbmNlUHJvcHMsIG9mZnNldCkge1xuICB2YXIgaXRlbU1ldGFkYXRhTWFwLCBsYXN0TWVhc3VyZWRJbmRleDtcblxuICBpZiAoaXRlbVR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgaXRlbU1ldGFkYXRhTWFwID0gaW5zdGFuY2VQcm9wcy5jb2x1bW5NZXRhZGF0YU1hcDtcbiAgICBsYXN0TWVhc3VyZWRJbmRleCA9IGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkQ29sdW1uSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaXRlbU1ldGFkYXRhTWFwID0gaW5zdGFuY2VQcm9wcy5yb3dNZXRhZGF0YU1hcDtcbiAgICBsYXN0TWVhc3VyZWRJbmRleCA9IGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkUm93SW5kZXg7XG4gIH1cblxuICB2YXIgbGFzdE1lYXN1cmVkSXRlbU9mZnNldCA9IGxhc3RNZWFzdXJlZEluZGV4ID4gMCA/IGl0ZW1NZXRhZGF0YU1hcFtsYXN0TWVhc3VyZWRJbmRleF0ub2Zmc2V0IDogMDtcblxuICBpZiAobGFzdE1lYXN1cmVkSXRlbU9mZnNldCA+PSBvZmZzZXQpIHtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IG1lYXN1cmVkIGl0ZW1zIHdpdGhpbiB0aGlzIHJhbmdlIGp1c3QgdXNlIGEgYmluYXJ5IHNlYXJjaCBhcyBpdCdzIGZhc3Rlci5cbiAgICByZXR1cm4gZmluZE5lYXJlc3RJdGVtQmluYXJ5U2VhcmNoKGl0ZW1UeXBlLCBwcm9wcywgaW5zdGFuY2VQcm9wcywgbGFzdE1lYXN1cmVkSW5kZXgsIDAsIG9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgbWVhc3VyZWQgdGhpcyBoaWdoLCBmYWxsYmFjayB0byBhbiBleHBvbmVudGlhbCBzZWFyY2ggd2l0aCBhbiBpbm5lciBiaW5hcnkgc2VhcmNoLlxuICAgIC8vIFRoZSBleHBvbmVudGlhbCBzZWFyY2ggYXZvaWRzIHByZS1jb21wdXRpbmcgc2l6ZXMgZm9yIHRoZSBmdWxsIHNldCBvZiBpdGVtcyBhcyBhIGJpbmFyeSBzZWFyY2ggd291bGQuXG4gICAgLy8gVGhlIG92ZXJhbGwgY29tcGxleGl0eSBmb3IgdGhpcyBhcHByb2FjaCBpcyBPKGxvZyBuKS5cbiAgICByZXR1cm4gZmluZE5lYXJlc3RJdGVtRXhwb25lbnRpYWxTZWFyY2goaXRlbVR5cGUsIHByb3BzLCBpbnN0YW5jZVByb3BzLCBNYXRoLm1heCgwLCBsYXN0TWVhc3VyZWRJbmRleCksIG9mZnNldCk7XG4gIH1cbn07XG5cbnZhciBmaW5kTmVhcmVzdEl0ZW1CaW5hcnlTZWFyY2ggPSBmdW5jdGlvbiBmaW5kTmVhcmVzdEl0ZW1CaW5hcnlTZWFyY2goaXRlbVR5cGUsIHByb3BzLCBpbnN0YW5jZVByb3BzLCBoaWdoLCBsb3csIG9mZnNldCkge1xuICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICB2YXIgbWlkZGxlID0gbG93ICsgTWF0aC5mbG9vcigoaGlnaCAtIGxvdykgLyAyKTtcbiAgICB2YXIgY3VycmVudE9mZnNldCA9IGdldEl0ZW1NZXRhZGF0YShpdGVtVHlwZSwgcHJvcHMsIG1pZGRsZSwgaW5zdGFuY2VQcm9wcykub2Zmc2V0O1xuXG4gICAgaWYgKGN1cnJlbnRPZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50T2Zmc2V0ID4gb2Zmc2V0KSB7XG4gICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICB9XG4gIH1cblxuICBpZiAobG93ID4gMCkge1xuICAgIHJldHVybiBsb3cgLSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG52YXIgZmluZE5lYXJlc3RJdGVtRXhwb25lbnRpYWxTZWFyY2ggPSBmdW5jdGlvbiBmaW5kTmVhcmVzdEl0ZW1FeHBvbmVudGlhbFNlYXJjaChpdGVtVHlwZSwgcHJvcHMsIGluc3RhbmNlUHJvcHMsIGluZGV4LCBvZmZzZXQpIHtcbiAgdmFyIGl0ZW1Db3VudCA9IGl0ZW1UeXBlID09PSAnY29sdW1uJyA/IHByb3BzLmNvbHVtbkNvdW50IDogcHJvcHMucm93Q291bnQ7XG4gIHZhciBpbnRlcnZhbCA9IDE7XG5cbiAgd2hpbGUgKGluZGV4IDwgaXRlbUNvdW50ICYmIGdldEl0ZW1NZXRhZGF0YShpdGVtVHlwZSwgcHJvcHMsIGluZGV4LCBpbnN0YW5jZVByb3BzKS5vZmZzZXQgPCBvZmZzZXQpIHtcbiAgICBpbmRleCArPSBpbnRlcnZhbDtcbiAgICBpbnRlcnZhbCAqPSAyO1xuICB9XG5cbiAgcmV0dXJuIGZpbmROZWFyZXN0SXRlbUJpbmFyeVNlYXJjaChpdGVtVHlwZSwgcHJvcHMsIGluc3RhbmNlUHJvcHMsIE1hdGgubWluKGluZGV4LCBpdGVtQ291bnQgLSAxKSwgTWF0aC5mbG9vcihpbmRleCAvIDIpLCBvZmZzZXQpO1xufTtcblxudmFyIGdldE9mZnNldEZvckluZGV4QW5kQWxpZ25tZW50ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0Rm9ySW5kZXhBbmRBbGlnbm1lbnQoaXRlbVR5cGUsIHByb3BzLCBpbmRleCwgYWxpZ24sIHNjcm9sbE9mZnNldCwgaW5zdGFuY2VQcm9wcywgc2Nyb2xsYmFyU2l6ZSkge1xuICB2YXIgc2l6ZSA9IGl0ZW1UeXBlID09PSAnY29sdW1uJyA/IHByb3BzLndpZHRoIDogcHJvcHMuaGVpZ2h0O1xuICB2YXIgaXRlbU1ldGFkYXRhID0gZ2V0SXRlbU1ldGFkYXRhKGl0ZW1UeXBlLCBwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpOyAvLyBHZXQgZXN0aW1hdGVkIHRvdGFsIHNpemUgYWZ0ZXIgSXRlbU1ldGFkYXRhIGlzIGNvbXB1dGVkLFxuICAvLyBUbyBlbnN1cmUgaXQgcmVmbGVjdHMgYWN0dWFsIG1lYXN1cmVtZW50cyBpbnN0ZWFkIG9mIGp1c3QgZXN0aW1hdGVzLlxuXG4gIHZhciBlc3RpbWF0ZWRUb3RhbFNpemUgPSBpdGVtVHlwZSA9PT0gJ2NvbHVtbicgPyBnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoKHByb3BzLCBpbnN0YW5jZVByb3BzKSA6IGdldEVzdGltYXRlZFRvdGFsSGVpZ2h0KHByb3BzLCBpbnN0YW5jZVByb3BzKTtcbiAgdmFyIG1heE9mZnNldCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVzdGltYXRlZFRvdGFsU2l6ZSAtIHNpemUsIGl0ZW1NZXRhZGF0YS5vZmZzZXQpKTtcbiAgdmFyIG1pbk9mZnNldCA9IE1hdGgubWF4KDAsIGl0ZW1NZXRhZGF0YS5vZmZzZXQgLSBzaXplICsgc2Nyb2xsYmFyU2l6ZSArIGl0ZW1NZXRhZGF0YS5zaXplKTtcblxuICBpZiAoYWxpZ24gPT09ICdzbWFydCcpIHtcbiAgICBpZiAoc2Nyb2xsT2Zmc2V0ID49IG1pbk9mZnNldCAtIHNpemUgJiYgc2Nyb2xsT2Zmc2V0IDw9IG1heE9mZnNldCArIHNpemUpIHtcbiAgICAgIGFsaWduID0gJ2F1dG8nO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGlnbiA9ICdjZW50ZXInO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAoYWxpZ24pIHtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICByZXR1cm4gbWF4T2Zmc2V0O1xuXG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIHJldHVybiBtaW5PZmZzZXQ7XG5cbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgcmV0dXJuIE1hdGgucm91bmQobWluT2Zmc2V0ICsgKG1heE9mZnNldCAtIG1pbk9mZnNldCkgLyAyKTtcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoc2Nyb2xsT2Zmc2V0ID49IG1pbk9mZnNldCAmJiBzY3JvbGxPZmZzZXQgPD0gbWF4T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxPZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKG1pbk9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAvLyBCZWNhdXNlIHdlIG9ubHkgdGFrZSBpbnRvIGFjY291bnQgdGhlIHNjcm9sbGJhciBzaXplIHdoZW4gY2FsY3VsYXRpbmcgbWluT2Zmc2V0XG4gICAgICAgIC8vIHRoaXMgdmFsdWUgY2FuIGJlIGxhcmdlciB0aGFuIG1heE9mZnNldCB3aGVuIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgICAgcmV0dXJuIG1pbk9mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBtaW5PZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF4T2Zmc2V0O1xuICAgICAgfVxuXG4gIH1cbn07XG5cbnZhciBWYXJpYWJsZVNpemVHcmlkID0gLyojX19QVVJFX18qL2NyZWF0ZUdyaWRDb21wb25lbnQoe1xuICBnZXRDb2x1bW5PZmZzZXQ6IGZ1bmN0aW9uIGdldENvbHVtbk9mZnNldChwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpIHtcbiAgICByZXR1cm4gZ2V0SXRlbU1ldGFkYXRhKCdjb2x1bW4nLCBwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpLm9mZnNldDtcbiAgfSxcbiAgZ2V0Q29sdW1uU3RhcnRJbmRleEZvck9mZnNldDogZnVuY3Rpb24gZ2V0Q29sdW1uU3RhcnRJbmRleEZvck9mZnNldChwcm9wcywgc2Nyb2xsTGVmdCwgaW5zdGFuY2VQcm9wcykge1xuICAgIHJldHVybiBmaW5kTmVhcmVzdEl0ZW0oJ2NvbHVtbicsIHByb3BzLCBpbnN0YW5jZVByb3BzLCBzY3JvbGxMZWZ0KTtcbiAgfSxcbiAgZ2V0Q29sdW1uU3RvcEluZGV4Rm9yU3RhcnRJbmRleDogZnVuY3Rpb24gZ2V0Q29sdW1uU3RvcEluZGV4Rm9yU3RhcnRJbmRleChwcm9wcywgc3RhcnRJbmRleCwgc2Nyb2xsTGVmdCwgaW5zdGFuY2VQcm9wcykge1xuICAgIHZhciBjb2x1bW5Db3VudCA9IHByb3BzLmNvbHVtbkNvdW50LFxuICAgICAgICB3aWR0aCA9IHByb3BzLndpZHRoO1xuICAgIHZhciBpdGVtTWV0YWRhdGEgPSBnZXRJdGVtTWV0YWRhdGEoJ2NvbHVtbicsIHByb3BzLCBzdGFydEluZGV4LCBpbnN0YW5jZVByb3BzKTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gc2Nyb2xsTGVmdCArIHdpZHRoO1xuICAgIHZhciBvZmZzZXQgPSBpdGVtTWV0YWRhdGEub2Zmc2V0ICsgaXRlbU1ldGFkYXRhLnNpemU7XG4gICAgdmFyIHN0b3BJbmRleCA9IHN0YXJ0SW5kZXg7XG5cbiAgICB3aGlsZSAoc3RvcEluZGV4IDwgY29sdW1uQ291bnQgLSAxICYmIG9mZnNldCA8IG1heE9mZnNldCkge1xuICAgICAgc3RvcEluZGV4Kys7XG4gICAgICBvZmZzZXQgKz0gZ2V0SXRlbU1ldGFkYXRhKCdjb2x1bW4nLCBwcm9wcywgc3RvcEluZGV4LCBpbnN0YW5jZVByb3BzKS5zaXplO1xuICAgIH1cblxuICAgIHJldHVybiBzdG9wSW5kZXg7XG4gIH0sXG4gIGdldENvbHVtbldpZHRoOiBmdW5jdGlvbiBnZXRDb2x1bW5XaWR0aChwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VQcm9wcy5jb2x1bW5NZXRhZGF0YU1hcFtpbmRleF0uc2l6ZTtcbiAgfSxcbiAgZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQ6IGdldEVzdGltYXRlZFRvdGFsSGVpZ2h0LFxuICBnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoOiBnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoLFxuICBnZXRPZmZzZXRGb3JDb2x1bW5BbmRBbGlnbm1lbnQ6IGZ1bmN0aW9uIGdldE9mZnNldEZvckNvbHVtbkFuZEFsaWdubWVudChwcm9wcywgaW5kZXgsIGFsaWduLCBzY3JvbGxPZmZzZXQsIGluc3RhbmNlUHJvcHMsIHNjcm9sbGJhclNpemUpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0Rm9ySW5kZXhBbmRBbGlnbm1lbnQoJ2NvbHVtbicsIHByb3BzLCBpbmRleCwgYWxpZ24sIHNjcm9sbE9mZnNldCwgaW5zdGFuY2VQcm9wcywgc2Nyb2xsYmFyU2l6ZSk7XG4gIH0sXG4gIGdldE9mZnNldEZvclJvd0FuZEFsaWdubWVudDogZnVuY3Rpb24gZ2V0T2Zmc2V0Rm9yUm93QW5kQWxpZ25tZW50KHByb3BzLCBpbmRleCwgYWxpZ24sIHNjcm9sbE9mZnNldCwgaW5zdGFuY2VQcm9wcywgc2Nyb2xsYmFyU2l6ZSkge1xuICAgIHJldHVybiBnZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudCgncm93JywgcHJvcHMsIGluZGV4LCBhbGlnbiwgc2Nyb2xsT2Zmc2V0LCBpbnN0YW5jZVByb3BzLCBzY3JvbGxiYXJTaXplKTtcbiAgfSxcbiAgZ2V0Um93T2Zmc2V0OiBmdW5jdGlvbiBnZXRSb3dPZmZzZXQocHJvcHMsIGluZGV4LCBpbnN0YW5jZVByb3BzKSB7XG4gICAgcmV0dXJuIGdldEl0ZW1NZXRhZGF0YSgncm93JywgcHJvcHMsIGluZGV4LCBpbnN0YW5jZVByb3BzKS5vZmZzZXQ7XG4gIH0sXG4gIGdldFJvd0hlaWdodDogZnVuY3Rpb24gZ2V0Um93SGVpZ2h0KHByb3BzLCBpbmRleCwgaW5zdGFuY2VQcm9wcykge1xuICAgIHJldHVybiBpbnN0YW5jZVByb3BzLnJvd01ldGFkYXRhTWFwW2luZGV4XS5zaXplO1xuICB9LFxuICBnZXRSb3dTdGFydEluZGV4Rm9yT2Zmc2V0OiBmdW5jdGlvbiBnZXRSb3dTdGFydEluZGV4Rm9yT2Zmc2V0KHByb3BzLCBzY3JvbGxUb3AsIGluc3RhbmNlUHJvcHMpIHtcbiAgICByZXR1cm4gZmluZE5lYXJlc3RJdGVtKCdyb3cnLCBwcm9wcywgaW5zdGFuY2VQcm9wcywgc2Nyb2xsVG9wKTtcbiAgfSxcbiAgZ2V0Um93U3RvcEluZGV4Rm9yU3RhcnRJbmRleDogZnVuY3Rpb24gZ2V0Um93U3RvcEluZGV4Rm9yU3RhcnRJbmRleChwcm9wcywgc3RhcnRJbmRleCwgc2Nyb2xsVG9wLCBpbnN0YW5jZVByb3BzKSB7XG4gICAgdmFyIHJvd0NvdW50ID0gcHJvcHMucm93Q291bnQsXG4gICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodDtcbiAgICB2YXIgaXRlbU1ldGFkYXRhID0gZ2V0SXRlbU1ldGFkYXRhKCdyb3cnLCBwcm9wcywgc3RhcnRJbmRleCwgaW5zdGFuY2VQcm9wcyk7XG4gICAgdmFyIG1heE9mZnNldCA9IHNjcm9sbFRvcCArIGhlaWdodDtcbiAgICB2YXIgb2Zmc2V0ID0gaXRlbU1ldGFkYXRhLm9mZnNldCArIGl0ZW1NZXRhZGF0YS5zaXplO1xuICAgIHZhciBzdG9wSW5kZXggPSBzdGFydEluZGV4O1xuXG4gICAgd2hpbGUgKHN0b3BJbmRleCA8IHJvd0NvdW50IC0gMSAmJiBvZmZzZXQgPCBtYXhPZmZzZXQpIHtcbiAgICAgIHN0b3BJbmRleCsrO1xuICAgICAgb2Zmc2V0ICs9IGdldEl0ZW1NZXRhZGF0YSgncm93JywgcHJvcHMsIHN0b3BJbmRleCwgaW5zdGFuY2VQcm9wcykuc2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RvcEluZGV4O1xuICB9LFxuICBpbml0SW5zdGFuY2VQcm9wczogZnVuY3Rpb24gaW5pdEluc3RhbmNlUHJvcHMocHJvcHMsIGluc3RhbmNlKSB7XG4gICAgdmFyIF9yZWY1ID0gcHJvcHMsXG4gICAgICAgIGVzdGltYXRlZENvbHVtbldpZHRoID0gX3JlZjUuZXN0aW1hdGVkQ29sdW1uV2lkdGgsXG4gICAgICAgIGVzdGltYXRlZFJvd0hlaWdodCA9IF9yZWY1LmVzdGltYXRlZFJvd0hlaWdodDtcbiAgICB2YXIgaW5zdGFuY2VQcm9wcyA9IHtcbiAgICAgIGNvbHVtbk1ldGFkYXRhTWFwOiB7fSxcbiAgICAgIGVzdGltYXRlZENvbHVtbldpZHRoOiBlc3RpbWF0ZWRDb2x1bW5XaWR0aCB8fCBERUZBVUxUX0VTVElNQVRFRF9JVEVNX1NJWkUsXG4gICAgICBlc3RpbWF0ZWRSb3dIZWlnaHQ6IGVzdGltYXRlZFJvd0hlaWdodCB8fCBERUZBVUxUX0VTVElNQVRFRF9JVEVNX1NJWkUsXG4gICAgICBsYXN0TWVhc3VyZWRDb2x1bW5JbmRleDogLTEsXG4gICAgICBsYXN0TWVhc3VyZWRSb3dJbmRleDogLTEsXG4gICAgICByb3dNZXRhZGF0YU1hcDoge31cbiAgICB9O1xuXG4gICAgaW5zdGFuY2UucmVzZXRBZnRlckNvbHVtbkluZGV4ID0gZnVuY3Rpb24gKGNvbHVtbkluZGV4LCBzaG91bGRGb3JjZVVwZGF0ZSkge1xuICAgICAgaWYgKHNob3VsZEZvcmNlVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hvdWxkRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5yZXNldEFmdGVySW5kaWNlcyh7XG4gICAgICAgIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgc2hvdWxkRm9yY2VVcGRhdGU6IHNob3VsZEZvcmNlVXBkYXRlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UucmVzZXRBZnRlclJvd0luZGV4ID0gZnVuY3Rpb24gKHJvd0luZGV4LCBzaG91bGRGb3JjZVVwZGF0ZSkge1xuICAgICAgaWYgKHNob3VsZEZvcmNlVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hvdWxkRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5yZXNldEFmdGVySW5kaWNlcyh7XG4gICAgICAgIHJvd0luZGV4OiByb3dJbmRleCxcbiAgICAgICAgc2hvdWxkRm9yY2VVcGRhdGU6IHNob3VsZEZvcmNlVXBkYXRlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UucmVzZXRBZnRlckluZGljZXMgPSBmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICAgIHZhciBjb2x1bW5JbmRleCA9IF9yZWY2LmNvbHVtbkluZGV4LFxuICAgICAgICAgIHJvd0luZGV4ID0gX3JlZjYucm93SW5kZXgsXG4gICAgICAgICAgX3JlZjYkc2hvdWxkRm9yY2VVcGRhID0gX3JlZjYuc2hvdWxkRm9yY2VVcGRhdGUsXG4gICAgICAgICAgc2hvdWxkRm9yY2VVcGRhdGUgPSBfcmVmNiRzaG91bGRGb3JjZVVwZGEgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmNiRzaG91bGRGb3JjZVVwZGE7XG5cbiAgICAgIGlmICh0eXBlb2YgY29sdW1uSW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkQ29sdW1uSW5kZXggPSBNYXRoLm1pbihpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZENvbHVtbkluZGV4LCBjb2x1bW5JbmRleCAtIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJvd0luZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZFJvd0luZGV4ID0gTWF0aC5taW4oaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRSb3dJbmRleCwgcm93SW5kZXggLSAxKTtcbiAgICAgIH0gLy8gV2UgY291bGQgcG90ZW50aWFsbHkgb3B0aW1pemUgZnVydGhlciBieSBvbmx5IGV2aWN0aW5nIHN0eWxlcyBhZnRlciB0aGlzIGluZGV4LFxuICAgICAgLy8gQnV0IHNpbmNlIHN0eWxlcyBhcmUgb25seSBjYWNoZWQgd2hpbGUgc2Nyb2xsaW5nIGlzIGluIHByb2dyZXNzLVxuICAgICAgLy8gSXQgc2VlbXMgYW4gdW5uZWNlc3Nhcnkgb3B0aW1pemF0aW9uLlxuICAgICAgLy8gSXQncyB1bmxpa2VseSB0aGF0IHJlc2V0QWZ0ZXJJbmRleCgpIHdpbGwgYmUgY2FsbGVkIHdoaWxlIGEgdXNlciBpcyBzY3JvbGxpbmcuXG5cblxuICAgICAgaW5zdGFuY2UuX2dldEl0ZW1TdHlsZUNhY2hlKC0xKTtcblxuICAgICAgaWYgKHNob3VsZEZvcmNlVXBkYXRlKSB7XG4gICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBpbnN0YW5jZVByb3BzO1xuICB9LFxuICBzaG91bGRSZXNldFN0eWxlQ2FjaGVPbkl0ZW1TaXplQ2hhbmdlOiBmYWxzZSxcbiAgdmFsaWRhdGVQcm9wczogZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhfcmVmNykge1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IF9yZWY3LmNvbHVtbldpZHRoLFxuICAgICAgICByb3dIZWlnaHQgPSBfcmVmNy5yb3dIZWlnaHQ7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBjb2x1bW5XaWR0aCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBFcnJvcignQW4gaW52YWxpZCBcImNvbHVtbldpZHRoXCIgcHJvcCBoYXMgYmVlbiBzcGVjaWZpZWQuICcgKyAnVmFsdWUgc2hvdWxkIGJlIGEgZnVuY3Rpb24uICcgKyAoXCJcXFwiXCIgKyAoY29sdW1uV2lkdGggPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgY29sdW1uV2lkdGgpICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJvd0hlaWdodCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBFcnJvcignQW4gaW52YWxpZCBcInJvd0hlaWdodFwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ1ZhbHVlIHNob3VsZCBiZSBhIGZ1bmN0aW9uLiAnICsgKFwiXFxcIlwiICsgKHJvd0hlaWdodCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByb3dIZWlnaHQpICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgSVNfU0NST0xMSU5HX0RFQk9VTkNFX0lOVEVSVkFMJDEgPSAxNTA7XG5cbnZhciBkZWZhdWx0SXRlbUtleSQxID0gZnVuY3Rpb24gZGVmYXVsdEl0ZW1LZXkoaW5kZXgsIGRhdGEpIHtcbiAgcmV0dXJuIGluZGV4O1xufTsgLy8gSW4gREVWIG1vZGUsIHRoaXMgU2V0IGhlbHBzIHVzIG9ubHkgbG9nIGEgd2FybmluZyBvbmNlIHBlciBjb21wb25lbnQgaW5zdGFuY2UuXG4vLyBUaGlzIGF2b2lkcyBzcGFtbWluZyB0aGUgY29uc29sZSBldmVyeSB0aW1lIGEgcmVuZGVyIGhhcHBlbnMuXG5cblxudmFyIGRldldhcm5pbmdzRGlyZWN0aW9uID0gbnVsbDtcbnZhciBkZXZXYXJuaW5nc1RhZ05hbWUkMSA9IG51bGw7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LldlYWtTZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGV2V2FybmluZ3NEaXJlY3Rpb24gPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtTZXQoKTtcbiAgICBkZXZXYXJuaW5nc1RhZ05hbWUkMSA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RDb21wb25lbnQoX3JlZikge1xuICB2YXIgX2NsYXNzO1xuXG4gIHZhciBnZXRJdGVtT2Zmc2V0ID0gX3JlZi5nZXRJdGVtT2Zmc2V0LFxuICAgICAgZ2V0RXN0aW1hdGVkVG90YWxTaXplID0gX3JlZi5nZXRFc3RpbWF0ZWRUb3RhbFNpemUsXG4gICAgICBnZXRJdGVtU2l6ZSA9IF9yZWYuZ2V0SXRlbVNpemUsXG4gICAgICBnZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudCA9IF9yZWYuZ2V0T2Zmc2V0Rm9ySW5kZXhBbmRBbGlnbm1lbnQsXG4gICAgICBnZXRTdGFydEluZGV4Rm9yT2Zmc2V0ID0gX3JlZi5nZXRTdGFydEluZGV4Rm9yT2Zmc2V0LFxuICAgICAgZ2V0U3RvcEluZGV4Rm9yU3RhcnRJbmRleCA9IF9yZWYuZ2V0U3RvcEluZGV4Rm9yU3RhcnRJbmRleCxcbiAgICAgIGluaXRJbnN0YW5jZVByb3BzID0gX3JlZi5pbml0SW5zdGFuY2VQcm9wcyxcbiAgICAgIHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UgPSBfcmVmLnNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UsXG4gICAgICB2YWxpZGF0ZVByb3BzID0gX3JlZi52YWxpZGF0ZVByb3BzO1xuICByZXR1cm4gX2NsYXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKExpc3QsIF9QdXJlQ29tcG9uZW50KTtcblxuICAgIC8vIEFsd2F5cyB1c2UgZXhwbGljaXQgY29uc3RydWN0b3IgZm9yIFJlYWN0IGNvbXBvbmVudHMuXG4gICAgLy8gSXQgcHJvZHVjZXMgbGVzcyBjb2RlIGFmdGVyIHRyYW5zcGlsYXRpb24uICgjMjYpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgICBmdW5jdGlvbiBMaXN0KHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX1B1cmVDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgIF90aGlzLl9pbnN0YW5jZVByb3BzID0gaW5pdEluc3RhbmNlUHJvcHMoX3RoaXMucHJvcHMsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLl9vdXRlclJlZiA9IHZvaWQgMDtcbiAgICAgIF90aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkID0gbnVsbDtcbiAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICBpbnN0YW5jZTogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXG4gICAgICAgIGlzU2Nyb2xsaW5nOiBmYWxzZSxcbiAgICAgICAgc2Nyb2xsRGlyZWN0aW9uOiAnZm9yd2FyZCcsXG4gICAgICAgIHNjcm9sbE9mZnNldDogdHlwZW9mIF90aGlzLnByb3BzLmluaXRpYWxTY3JvbGxPZmZzZXQgPT09ICdudW1iZXInID8gX3RoaXMucHJvcHMuaW5pdGlhbFNjcm9sbE9mZnNldCA6IDAsXG4gICAgICAgIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBfdGhpcy5fY2FsbE9uSXRlbXNSZW5kZXJlZCA9IHZvaWQgMDtcbiAgICAgIF90aGlzLl9jYWxsT25JdGVtc1JlbmRlcmVkID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAob3ZlcnNjYW5TdGFydEluZGV4LCBvdmVyc2NhblN0b3BJbmRleCwgdmlzaWJsZVN0YXJ0SW5kZXgsIHZpc2libGVTdG9wSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9uSXRlbXNSZW5kZXJlZCh7XG4gICAgICAgICAgb3ZlcnNjYW5TdGFydEluZGV4OiBvdmVyc2NhblN0YXJ0SW5kZXgsXG4gICAgICAgICAgb3ZlcnNjYW5TdG9wSW5kZXg6IG92ZXJzY2FuU3RvcEluZGV4LFxuICAgICAgICAgIHZpc2libGVTdGFydEluZGV4OiB2aXNpYmxlU3RhcnRJbmRleCxcbiAgICAgICAgICB2aXNpYmxlU3RvcEluZGV4OiB2aXNpYmxlU3RvcEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5fY2FsbE9uU2Nyb2xsID0gdm9pZCAwO1xuICAgICAgX3RoaXMuX2NhbGxPblNjcm9sbCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKHNjcm9sbERpcmVjdGlvbiwgc2Nyb2xsT2Zmc2V0LCBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9uU2Nyb2xsKHtcbiAgICAgICAgICBzY3JvbGxEaXJlY3Rpb246IHNjcm9sbERpcmVjdGlvbixcbiAgICAgICAgICBzY3JvbGxPZmZzZXQ6IHNjcm9sbE9mZnNldCxcbiAgICAgICAgICBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQ6IHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuX2dldEl0ZW1TdHlsZSA9IHZvaWQgMDtcblxuICAgICAgX3RoaXMuX2dldEl0ZW1TdHlsZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IF90aGlzJHByb3BzLmRpcmVjdGlvbixcbiAgICAgICAgICAgIGl0ZW1TaXplID0gX3RoaXMkcHJvcHMuaXRlbVNpemUsXG4gICAgICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wcy5sYXlvdXQ7XG5cbiAgICAgICAgdmFyIGl0ZW1TdHlsZUNhY2hlID0gX3RoaXMuX2dldEl0ZW1TdHlsZUNhY2hlKHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UgJiYgaXRlbVNpemUsIHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UgJiYgbGF5b3V0LCBzaG91bGRSZXNldFN0eWxlQ2FjaGVPbkl0ZW1TaXplQ2hhbmdlICYmIGRpcmVjdGlvbik7XG5cbiAgICAgICAgdmFyIHN0eWxlO1xuXG4gICAgICAgIGlmIChpdGVtU3R5bGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcbiAgICAgICAgICBzdHlsZSA9IGl0ZW1TdHlsZUNhY2hlW2luZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX29mZnNldCA9IGdldEl0ZW1PZmZzZXQoX3RoaXMucHJvcHMsIGluZGV4LCBfdGhpcy5faW5zdGFuY2VQcm9wcyk7XG5cbiAgICAgICAgICB2YXIgc2l6ZSA9IGdldEl0ZW1TaXplKF90aGlzLnByb3BzLCBpbmRleCwgX3RoaXMuX2luc3RhbmNlUHJvcHMpOyAvLyBUT0RPIERlcHJlY2F0ZSBkaXJlY3Rpb24gXCJob3Jpem9udGFsXCJcblxuICAgICAgICAgIHZhciBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyB8fCBsYXlvdXQgPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09ICdydGwnO1xuICAgICAgICAgIHZhciBvZmZzZXRIb3Jpem9udGFsID0gaXNIb3Jpem9udGFsID8gX29mZnNldCA6IDA7XG4gICAgICAgICAgaXRlbVN0eWxlQ2FjaGVbaW5kZXhdID0gc3R5bGUgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGxlZnQ6IGlzUnRsID8gdW5kZWZpbmVkIDogb2Zmc2V0SG9yaXpvbnRhbCxcbiAgICAgICAgICAgIHJpZ2h0OiBpc1J0bCA/IG9mZnNldEhvcml6b250YWwgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0b3A6ICFpc0hvcml6b250YWwgPyBfb2Zmc2V0IDogMCxcbiAgICAgICAgICAgIGhlaWdodDogIWlzSG9yaXpvbnRhbCA/IHNpemUgOiAnMTAwJScsXG4gICAgICAgICAgICB3aWR0aDogaXNIb3Jpem9udGFsID8gc2l6ZSA6ICcxMDAlJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5fZ2V0SXRlbVN0eWxlQ2FjaGUgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5fZ2V0SXRlbVN0eWxlQ2FjaGUgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChfLCBfXywgX19fKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5fb25TY3JvbGxIb3Jpem9udGFsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfZXZlbnQkY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICBjbGllbnRXaWR0aCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICBzY3JvbGxXaWR0aCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0LnNjcm9sbFdpZHRoO1xuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgICAgICBpZiAocHJldlN0YXRlLnNjcm9sbE9mZnNldCA9PT0gc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIHBvc2l0aW9uIG1heSBoYXZlIGJlZW4gdXBkYXRlZCBieSBjRE0vY0RVLFxuICAgICAgICAgICAgLy8gSW4gd2hpY2ggY2FzZSB3ZSBkb24ndCBuZWVkIHRvIHRyaWdnZXIgYW5vdGhlciByZW5kZXIsXG4gICAgICAgICAgICAvLyBBbmQgd2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgc3RhdGUuaXNTY3JvbGxpbmcuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gX3RoaXMucHJvcHMuZGlyZWN0aW9uO1xuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXQgPSBzY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgIC8vIFRSSUNLWSBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNjcm9sbExlZnQgc2hvdWxkIGJlIG5lZ2F0aXZlIGZvciBSVEwgYWxpZ25lZCBlbGVtZW50cy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IHRoZSBjYXNlIGZvciBhbGwgYnJvd3NlcnMgdGhvdWdoIChlLmcuIENocm9tZSByZXBvcnRzIHZhbHVlcyBhcyBwb3NpdGl2ZSwgbWVhc3VyZWQgcmVsYXRpdmUgdG8gdGhlIGxlZnQpLlxuICAgICAgICAgICAgLy8gSXQncyBhbHNvIGVhc2llciBmb3IgdGhpcyBjb21wb25lbnQgaWYgd2UgY29udmVydCBvZmZzZXRzIHRvIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGV5IHdvdWxkIGJlIGluIGZvciBsdHIuXG4gICAgICAgICAgICAvLyBTbyB0aGUgc2ltcGxlc3Qgc29sdXRpb24gaXMgdG8gZGV0ZXJtaW5lIHdoaWNoIGJyb3dzZXIgYmVoYXZpb3Igd2UncmUgZGVhbGluZyB3aXRoLCBhbmQgY29udmVydCBiYXNlZCBvbiBpdC5cbiAgICAgICAgICAgIHN3aXRjaCAoZ2V0UlRMT2Zmc2V0VHlwZSgpKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ25lZ2F0aXZlJzpcbiAgICAgICAgICAgICAgICBzY3JvbGxPZmZzZXQgPSAtc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdwb3NpdGl2ZS1kZXNjZW5kaW5nJzpcbiAgICAgICAgICAgICAgICBzY3JvbGxPZmZzZXQgPSBzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoIC0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFByZXZlbnQgU2FmYXJpJ3MgZWxhc3RpYyBzY3JvbGxpbmcgZnJvbSBjYXVzaW5nIHZpc3VhbCBzaGFraW5nIHdoZW4gc2Nyb2xsaW5nIHBhc3QgYm91bmRzLlxuXG5cbiAgICAgICAgICBzY3JvbGxPZmZzZXQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGxPZmZzZXQsIHNjcm9sbFdpZHRoIC0gY2xpZW50V2lkdGgpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHRydWUsXG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb246IHByZXZTdGF0ZS5zY3JvbGxPZmZzZXQgPCBzY3JvbGxPZmZzZXQgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnLFxuICAgICAgICAgICAgc2Nyb2xsT2Zmc2V0OiBzY3JvbGxPZmZzZXQsXG4gICAgICAgICAgICBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdEZWJvdW5jZWQpO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuX29uU2Nyb2xsVmVydGljYWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9ldmVudCRjdXJyZW50VGFyZ2V0MiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQgPSBfZXZlbnQkY3VycmVudFRhcmdldDIuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQyLnNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0Mi5zY3JvbGxUb3A7XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgICAgIGlmIChwcmV2U3RhdGUuc2Nyb2xsT2Zmc2V0ID09PSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIC8vIFNjcm9sbCBwb3NpdGlvbiBtYXkgaGF2ZSBiZWVuIHVwZGF0ZWQgYnkgY0RNL2NEVSxcbiAgICAgICAgICAgIC8vIEluIHdoaWNoIGNhc2Ugd2UgZG9uJ3QgbmVlZCB0byB0cmlnZ2VyIGFub3RoZXIgcmVuZGVyLFxuICAgICAgICAgICAgLy8gQW5kIHdlIGRvbid0IHdhbnQgdG8gdXBkYXRlIHN0YXRlLmlzU2Nyb2xsaW5nLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSAvLyBQcmV2ZW50IFNhZmFyaSdzIGVsYXN0aWMgc2Nyb2xsaW5nIGZyb20gY2F1c2luZyB2aXN1YWwgc2hha2luZyB3aGVuIHNjcm9sbGluZyBwYXN0IGJvdW5kcy5cblxuXG4gICAgICAgICAgdmFyIHNjcm9sbE9mZnNldCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0IC0gY2xpZW50SGVpZ2h0KSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzU2Nyb2xsaW5nOiB0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uOiBwcmV2U3RhdGUuc2Nyb2xsT2Zmc2V0IDwgc2Nyb2xsT2Zmc2V0ID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJyxcbiAgICAgICAgICAgIHNjcm9sbE9mZnNldDogc2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgICAgc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH0sIF90aGlzLl9yZXNldElzU2Nyb2xsaW5nRGVib3VuY2VkKTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLl9vdXRlclJlZlNldHRlciA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIG91dGVyUmVmID0gX3RoaXMucHJvcHMub3V0ZXJSZWY7XG4gICAgICAgIF90aGlzLl9vdXRlclJlZiA9IHJlZjtcblxuICAgICAgICBpZiAodHlwZW9mIG91dGVyUmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb3V0ZXJSZWYocmVmKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdXRlclJlZiAhPSBudWxsICYmIHR5cGVvZiBvdXRlclJlZiA9PT0gJ29iamVjdCcgJiYgb3V0ZXJSZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICAgIG91dGVyUmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF90aGlzLl9yZXNldElzU2Nyb2xsaW5nRGVib3VuY2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICBjYW5jZWxUaW1lb3V0KF90aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkID0gcmVxdWVzdFRpbWVvdXQoX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmcsIElTX1NDUk9MTElOR19ERUJPVU5DRV9JTlRFUlZBTCQxKTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLl9yZXNldElzU2Nyb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ1RpbWVvdXRJZCA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGlzU2Nyb2xsaW5nOiBmYWxzZVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gQ2xlYXIgc3R5bGUgY2FjaGUgYWZ0ZXIgc3RhdGUgdXBkYXRlIGhhcyBiZWVuIGNvbW1pdHRlZC5cbiAgICAgICAgICAvLyBUaGlzIHdheSB3ZSBkb24ndCBicmVhayBwdXJlIHNDVSBmb3IgaXRlbXMgdGhhdCBkb24ndCB1c2UgaXNTY3JvbGxpbmcgcGFyYW0uXG4gICAgICAgICAgX3RoaXMuX2dldEl0ZW1TdHlsZUNhY2hlKC0xLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgTGlzdC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHZhbGlkYXRlU2hhcmVkUHJvcHMkMShuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICB2YWxpZGF0ZVByb3BzKG5leHRQcm9wcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIF9wcm90byA9IExpc3QucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNjcm9sbFRvID0gZnVuY3Rpb24gc2Nyb2xsVG8oc2Nyb2xsT2Zmc2V0KSB7XG4gICAgICBzY3JvbGxPZmZzZXQgPSBNYXRoLm1heCgwLCBzY3JvbGxPZmZzZXQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgIGlmIChwcmV2U3RhdGUuc2Nyb2xsT2Zmc2V0ID09PSBzY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uOiBwcmV2U3RhdGUuc2Nyb2xsT2Zmc2V0IDwgc2Nyb2xsT2Zmc2V0ID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJyxcbiAgICAgICAgICBzY3JvbGxPZmZzZXQ6IHNjcm9sbE9mZnNldCxcbiAgICAgICAgICBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMuX3Jlc2V0SXNTY3JvbGxpbmdEZWJvdW5jZWQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc2Nyb2xsVG9JdGVtID0gZnVuY3Rpb24gc2Nyb2xsVG9JdGVtKGluZGV4LCBhbGlnbikge1xuICAgICAgaWYgKGFsaWduID09PSB2b2lkIDApIHtcbiAgICAgICAgYWxpZ24gPSAnYXV0byc7XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGl0ZW1Db3VudCA9IF90aGlzJHByb3BzMi5pdGVtQ291bnQsXG4gICAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHMyLmxheW91dDtcbiAgICAgIHZhciBzY3JvbGxPZmZzZXQgPSB0aGlzLnN0YXRlLnNjcm9sbE9mZnNldDtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGl0ZW1Db3VudCAtIDEpKTsgLy8gVGhlIHNjcm9sbGJhciBzaXplIHNob3VsZCBiZSBjb25zaWRlcmVkIHdoZW4gc2Nyb2xsaW5nIGFuIGl0ZW0gaW50byB2aWV3LCB0byBlbnN1cmUgaXQncyBmdWxseSB2aXNpYmxlLlxuICAgICAgLy8gQnV0IHdlIG9ubHkgbmVlZCB0byBhY2NvdW50IGZvciBpdHMgc2l6ZSB3aGVuIGl0J3MgYWN0dWFsbHkgdmlzaWJsZS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gZWRnZSBjYXNlIGZvciBsaXN0czsgbm9ybWFsbHkgdGhleSBvbmx5IHNjcm9sbCBpbiB0aGUgZG9taW5hbnQgZGlyZWN0aW9uLlxuXG4gICAgICB2YXIgc2Nyb2xsYmFyU2l6ZSA9IDA7XG5cbiAgICAgIGlmICh0aGlzLl9vdXRlclJlZikge1xuICAgICAgICB2YXIgb3V0ZXJSZWYgPSB0aGlzLl9vdXRlclJlZjtcblxuICAgICAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgc2Nyb2xsYmFyU2l6ZSA9IG91dGVyUmVmLnNjcm9sbFdpZHRoID4gb3V0ZXJSZWYuY2xpZW50V2lkdGggPyBnZXRTY3JvbGxiYXJTaXplKCkgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbGJhclNpemUgPSBvdXRlclJlZi5zY3JvbGxIZWlnaHQgPiBvdXRlclJlZi5jbGllbnRIZWlnaHQgPyBnZXRTY3JvbGxiYXJTaXplKCkgOiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2Nyb2xsVG8oZ2V0T2Zmc2V0Rm9ySW5kZXhBbmRBbGlnbm1lbnQodGhpcy5wcm9wcywgaW5kZXgsIGFsaWduLCBzY3JvbGxPZmZzZXQsIHRoaXMuX2luc3RhbmNlUHJvcHMsIHNjcm9sbGJhclNpemUpKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkaXJlY3Rpb24gPSBfdGhpcyRwcm9wczMuZGlyZWN0aW9uLFxuICAgICAgICAgIGluaXRpYWxTY3JvbGxPZmZzZXQgPSBfdGhpcyRwcm9wczMuaW5pdGlhbFNjcm9sbE9mZnNldCxcbiAgICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wczMubGF5b3V0O1xuXG4gICAgICBpZiAodHlwZW9mIGluaXRpYWxTY3JvbGxPZmZzZXQgPT09ICdudW1iZXInICYmIHRoaXMuX291dGVyUmVmICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG91dGVyUmVmID0gdGhpcy5fb3V0ZXJSZWY7IC8vIFRPRE8gRGVwcmVjYXRlIGRpcmVjdGlvbiBcImhvcml6b250YWxcIlxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyB8fCBsYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgIG91dGVyUmVmLnNjcm9sbExlZnQgPSBpbml0aWFsU2Nyb2xsT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dGVyUmVmLnNjcm9sbFRvcCA9IGluaXRpYWxTY3JvbGxPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FsbFByb3BzQ2FsbGJhY2tzKCk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkaXJlY3Rpb24gPSBfdGhpcyRwcm9wczQuZGlyZWN0aW9uLFxuICAgICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzNC5sYXlvdXQ7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIHNjcm9sbE9mZnNldCA9IF90aGlzJHN0YXRlLnNjcm9sbE9mZnNldCxcbiAgICAgICAgICBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQgPSBfdGhpcyRzdGF0ZS5zY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQ7XG5cbiAgICAgIGlmIChzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQgJiYgdGhpcy5fb3V0ZXJSZWYgIT0gbnVsbCkge1xuICAgICAgICB2YXIgb3V0ZXJSZWYgPSB0aGlzLl9vdXRlclJlZjsgLy8gVE9ETyBEZXByZWNhdGUgZGlyZWN0aW9uIFwiaG9yaXpvbnRhbFwiXG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnIHx8IGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgIC8vIFRSSUNLWSBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNjcm9sbExlZnQgc2hvdWxkIGJlIG5lZ2F0aXZlIGZvciBSVEwgYWxpZ25lZCBlbGVtZW50cy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IHRoZSBjYXNlIGZvciBhbGwgYnJvd3NlcnMgdGhvdWdoIChlLmcuIENocm9tZSByZXBvcnRzIHZhbHVlcyBhcyBwb3NpdGl2ZSwgbWVhc3VyZWQgcmVsYXRpdmUgdG8gdGhlIGxlZnQpLlxuICAgICAgICAgICAgLy8gU28gd2UgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2ggYnJvd3NlciBiZWhhdmlvciB3ZSdyZSBkZWFsaW5nIHdpdGgsIGFuZCBtaW1pYyBpdC5cbiAgICAgICAgICAgIHN3aXRjaCAoZ2V0UlRMT2Zmc2V0VHlwZSgpKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ25lZ2F0aXZlJzpcbiAgICAgICAgICAgICAgICBvdXRlclJlZi5zY3JvbGxMZWZ0ID0gLXNjcm9sbE9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdwb3NpdGl2ZS1hc2NlbmRpbmcnOlxuICAgICAgICAgICAgICAgIG91dGVyUmVmLnNjcm9sbExlZnQgPSBzY3JvbGxPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50V2lkdGggPSBvdXRlclJlZi5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsV2lkdGggPSBvdXRlclJlZi5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICBvdXRlclJlZi5zY3JvbGxMZWZ0ID0gc2Nyb2xsV2lkdGggLSBjbGllbnRXaWR0aCAtIHNjcm9sbE9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsTGVmdCA9IHNjcm9sbE9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsVG9wID0gc2Nyb2xsT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhbGxQcm9wc0NhbGxiYWNrcygpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQodGhpcy5fcmVzZXRJc1Njcm9sbGluZ1RpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNS5jaGlsZHJlbixcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczUuY2xhc3NOYW1lLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF90aGlzJHByb3BzNS5kaXJlY3Rpb24sXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM1LmhlaWdodCxcbiAgICAgICAgICBpbm5lclJlZiA9IF90aGlzJHByb3BzNS5pbm5lclJlZixcbiAgICAgICAgICBpbm5lckVsZW1lbnRUeXBlID0gX3RoaXMkcHJvcHM1LmlubmVyRWxlbWVudFR5cGUsXG4gICAgICAgICAgaW5uZXJUYWdOYW1lID0gX3RoaXMkcHJvcHM1LmlubmVyVGFnTmFtZSxcbiAgICAgICAgICBpdGVtQ291bnQgPSBfdGhpcyRwcm9wczUuaXRlbUNvdW50LFxuICAgICAgICAgIGl0ZW1EYXRhID0gX3RoaXMkcHJvcHM1Lml0ZW1EYXRhLFxuICAgICAgICAgIF90aGlzJHByb3BzNSRpdGVtS2V5ID0gX3RoaXMkcHJvcHM1Lml0ZW1LZXksXG4gICAgICAgICAgaXRlbUtleSA9IF90aGlzJHByb3BzNSRpdGVtS2V5ID09PSB2b2lkIDAgPyBkZWZhdWx0SXRlbUtleSQxIDogX3RoaXMkcHJvcHM1JGl0ZW1LZXksXG4gICAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHM1LmxheW91dCxcbiAgICAgICAgICBvdXRlckVsZW1lbnRUeXBlID0gX3RoaXMkcHJvcHM1Lm91dGVyRWxlbWVudFR5cGUsXG4gICAgICAgICAgb3V0ZXJUYWdOYW1lID0gX3RoaXMkcHJvcHM1Lm91dGVyVGFnTmFtZSxcbiAgICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzNS5zdHlsZSxcbiAgICAgICAgICB1c2VJc1Njcm9sbGluZyA9IF90aGlzJHByb3BzNS51c2VJc1Njcm9sbGluZyxcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNS53aWR0aDtcbiAgICAgIHZhciBpc1Njcm9sbGluZyA9IHRoaXMuc3RhdGUuaXNTY3JvbGxpbmc7IC8vIFRPRE8gRGVwcmVjYXRlIGRpcmVjdGlvbiBcImhvcml6b250YWxcIlxuXG4gICAgICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgfHwgbGF5b3V0ID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICB2YXIgb25TY3JvbGwgPSBpc0hvcml6b250YWwgPyB0aGlzLl9vblNjcm9sbEhvcml6b250YWwgOiB0aGlzLl9vblNjcm9sbFZlcnRpY2FsO1xuXG4gICAgICB2YXIgX3RoaXMkX2dldFJhbmdlVG9SZW5kID0gdGhpcy5fZ2V0UmFuZ2VUb1JlbmRlcigpLFxuICAgICAgICAgIHN0YXJ0SW5kZXggPSBfdGhpcyRfZ2V0UmFuZ2VUb1JlbmRbMF0sXG4gICAgICAgICAgc3RvcEluZGV4ID0gX3RoaXMkX2dldFJhbmdlVG9SZW5kWzFdO1xuXG4gICAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgICAgaWYgKGl0ZW1Db3VudCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgX2luZGV4ID0gc3RhcnRJbmRleDsgX2luZGV4IDw9IHN0b3BJbmRleDsgX2luZGV4KyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGNyZWF0ZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICAgICAgICAgIGRhdGE6IGl0ZW1EYXRhLFxuICAgICAgICAgICAga2V5OiBpdGVtS2V5KF9pbmRleCwgaXRlbURhdGEpLFxuICAgICAgICAgICAgaW5kZXg6IF9pbmRleCxcbiAgICAgICAgICAgIGlzU2Nyb2xsaW5nOiB1c2VJc1Njcm9sbGluZyA/IGlzU2Nyb2xsaW5nIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3R5bGU6IHRoaXMuX2dldEl0ZW1TdHlsZShfaW5kZXgpXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlYWQgdGhpcyB2YWx1ZSBBRlRFUiBpdGVtcyBoYXZlIGJlZW4gY3JlYXRlZCxcbiAgICAgIC8vIFNvIHRoZWlyIGFjdHVhbCBzaXplcyAoaWYgdmFyaWFibGUpIGFyZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24uXG5cblxuICAgICAgdmFyIGVzdGltYXRlZFRvdGFsU2l6ZSA9IGdldEVzdGltYXRlZFRvdGFsU2l6ZSh0aGlzLnByb3BzLCB0aGlzLl9pbnN0YW5jZVByb3BzKTtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KG91dGVyRWxlbWVudFR5cGUgfHwgb3V0ZXJUYWdOYW1lIHx8ICdkaXYnLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBvblNjcm9sbDogb25TY3JvbGwsXG4gICAgICAgIHJlZjogdGhpcy5fb3V0ZXJSZWZTZXR0ZXIsXG4gICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICAgICAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6ICd0b3VjaCcsXG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybScsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfSwgc3R5bGUpXG4gICAgICB9LCBjcmVhdGVFbGVtZW50KGlubmVyRWxlbWVudFR5cGUgfHwgaW5uZXJUYWdOYW1lIHx8ICdkaXYnLCB7XG4gICAgICAgIGNoaWxkcmVuOiBpdGVtcyxcbiAgICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBoZWlnaHQ6IGlzSG9yaXpvbnRhbCA/ICcxMDAlJyA6IGVzdGltYXRlZFRvdGFsU2l6ZSxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBpc1Njcm9sbGluZyA/ICdub25lJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB3aWR0aDogaXNIb3Jpem9udGFsID8gZXN0aW1hdGVkVG90YWxTaXplIDogJzEwMCUnXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9jYWxsUHJvcHNDYWxsYmFja3MgPSBmdW5jdGlvbiBfY2FsbFByb3BzQ2FsbGJhY2tzKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uSXRlbXNSZW5kZXJlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgaXRlbUNvdW50ID0gdGhpcy5wcm9wcy5pdGVtQ291bnQ7XG5cbiAgICAgICAgaWYgKGl0ZW1Db3VudCA+IDApIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldFJhbmdlVG9SZW5kMiA9IHRoaXMuX2dldFJhbmdlVG9SZW5kZXIoKSxcbiAgICAgICAgICAgICAgX292ZXJzY2FuU3RhcnRJbmRleCA9IF90aGlzJF9nZXRSYW5nZVRvUmVuZDJbMF0sXG4gICAgICAgICAgICAgIF9vdmVyc2NhblN0b3BJbmRleCA9IF90aGlzJF9nZXRSYW5nZVRvUmVuZDJbMV0sXG4gICAgICAgICAgICAgIF92aXNpYmxlU3RhcnRJbmRleCA9IF90aGlzJF9nZXRSYW5nZVRvUmVuZDJbMl0sXG4gICAgICAgICAgICAgIF92aXNpYmxlU3RvcEluZGV4ID0gX3RoaXMkX2dldFJhbmdlVG9SZW5kMlszXTtcblxuICAgICAgICAgIHRoaXMuX2NhbGxPbkl0ZW1zUmVuZGVyZWQoX292ZXJzY2FuU3RhcnRJbmRleCwgX292ZXJzY2FuU3RvcEluZGV4LCBfdmlzaWJsZVN0YXJ0SW5kZXgsIF92aXNpYmxlU3RvcEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25TY3JvbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICBfc2Nyb2xsRGlyZWN0aW9uID0gX3RoaXMkc3RhdGUyLnNjcm9sbERpcmVjdGlvbixcbiAgICAgICAgICAgIF9zY3JvbGxPZmZzZXQgPSBfdGhpcyRzdGF0ZTIuc2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgICAgX3Njcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCA9IF90aGlzJHN0YXRlMi5zY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQ7XG5cbiAgICAgICAgdGhpcy5fY2FsbE9uU2Nyb2xsKF9zY3JvbGxEaXJlY3Rpb24sIF9zY3JvbGxPZmZzZXQsIF9zY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQpO1xuICAgICAgfVxuICAgIH0gLy8gTGF6aWx5IGNyZWF0ZSBhbmQgY2FjaGUgaXRlbSBzdHlsZXMgd2hpbGUgc2Nyb2xsaW5nLFxuICAgIC8vIFNvIHRoYXQgcHVyZSBjb21wb25lbnQgc0NVIHdpbGwgcHJldmVudCByZS1yZW5kZXJzLlxuICAgIC8vIFdlIG1haW50YWluIHRoaXMgY2FjaGUsIGFuZCBwYXNzIGEgc3R5bGUgcHJvcCByYXRoZXIgdGhhbiBpbmRleCxcbiAgICAvLyBTbyB0aGF0IExpc3QgY2FuIGNsZWFyIGNhY2hlZCBzdHlsZXMgYW5kIGZvcmNlIGl0ZW0gcmUtcmVuZGVyIGlmIG5lY2Vzc2FyeS5cbiAgICA7XG5cbiAgICBfcHJvdG8uX2dldFJhbmdlVG9SZW5kZXIgPSBmdW5jdGlvbiBfZ2V0UmFuZ2VUb1JlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGl0ZW1Db3VudCA9IF90aGlzJHByb3BzNi5pdGVtQ291bnQsXG4gICAgICAgICAgb3ZlcnNjYW5Db3VudCA9IF90aGlzJHByb3BzNi5vdmVyc2NhbkNvdW50O1xuICAgICAgdmFyIF90aGlzJHN0YXRlMyA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgaXNTY3JvbGxpbmcgPSBfdGhpcyRzdGF0ZTMuaXNTY3JvbGxpbmcsXG4gICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gX3RoaXMkc3RhdGUzLnNjcm9sbERpcmVjdGlvbixcbiAgICAgICAgICBzY3JvbGxPZmZzZXQgPSBfdGhpcyRzdGF0ZTMuc2Nyb2xsT2Zmc2V0O1xuXG4gICAgICBpZiAoaXRlbUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEluZGV4ID0gZ2V0U3RhcnRJbmRleEZvck9mZnNldCh0aGlzLnByb3BzLCBzY3JvbGxPZmZzZXQsIHRoaXMuX2luc3RhbmNlUHJvcHMpO1xuICAgICAgdmFyIHN0b3BJbmRleCA9IGdldFN0b3BJbmRleEZvclN0YXJ0SW5kZXgodGhpcy5wcm9wcywgc3RhcnRJbmRleCwgc2Nyb2xsT2Zmc2V0LCB0aGlzLl9pbnN0YW5jZVByb3BzKTsgLy8gT3ZlcnNjYW4gYnkgb25lIGl0ZW0gaW4gZWFjaCBkaXJlY3Rpb24gc28gdGhhdCB0YWIvZm9jdXMgd29ya3MuXG4gICAgICAvLyBJZiB0aGVyZSBpc24ndCBhdCBsZWFzdCBvbmUgZXh0cmEgaXRlbSwgdGFiIGxvb3BzIGJhY2sgYXJvdW5kLlxuXG4gICAgICB2YXIgb3ZlcnNjYW5CYWNrd2FyZCA9ICFpc1Njcm9sbGluZyB8fCBzY3JvbGxEaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyBNYXRoLm1heCgxLCBvdmVyc2NhbkNvdW50KSA6IDE7XG4gICAgICB2YXIgb3ZlcnNjYW5Gb3J3YXJkID0gIWlzU2Nyb2xsaW5nIHx8IHNjcm9sbERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gTWF0aC5tYXgoMSwgb3ZlcnNjYW5Db3VudCkgOiAxO1xuICAgICAgcmV0dXJuIFtNYXRoLm1heCgwLCBzdGFydEluZGV4IC0gb3ZlcnNjYW5CYWNrd2FyZCksIE1hdGgubWF4KDAsIE1hdGgubWluKGl0ZW1Db3VudCAtIDEsIHN0b3BJbmRleCArIG92ZXJzY2FuRm9yd2FyZCkpLCBzdGFydEluZGV4LCBzdG9wSW5kZXhdO1xuICAgIH07XG5cbiAgICByZXR1cm4gTGlzdDtcbiAgfShQdXJlQ29tcG9uZW50KSwgX2NsYXNzLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXJlY3Rpb246ICdsdHInLFxuICAgIGl0ZW1EYXRhOiB1bmRlZmluZWQsXG4gICAgbGF5b3V0OiAndmVydGljYWwnLFxuICAgIG92ZXJzY2FuQ291bnQ6IDIsXG4gICAgdXNlSXNTY3JvbGxpbmc6IGZhbHNlXG4gIH0sIF9jbGFzcztcbn0gLy8gTk9URTogSSBjb25zaWRlcmVkIGZ1cnRoZXIgd3JhcHBpbmcgaW5kaXZpZHVhbCBpdGVtcyB3aXRoIGEgcHVyZSBMaXN0SXRlbSBjb21wb25lbnQuXG4vLyBUaGlzIHdvdWxkIGF2b2lkIGV2ZXIgY2FsbGluZyB0aGUgcmVuZGVyIGZ1bmN0aW9uIGZvciB0aGUgc2FtZSBpbmRleCBtb3JlIHRoYW4gb25jZSxcbi8vIEJ1dCBpdCB3b3VsZCBhbHNvIGFkZCB0aGUgb3ZlcmhlYWQgb2YgYSBsb3Qgb2YgY29tcG9uZW50cy9maWJlcnMuXG4vLyBJIGFzc3VtZSBwZW9wbGUgYWxyZWFkeSBkbyB0aGlzIChyZW5kZXIgZnVuY3Rpb24gcmV0dXJuaW5nIGEgY2xhc3MgY29tcG9uZW50KSxcbi8vIFNvIG15IGRvaW5nIGl0IHdvdWxkIGp1c3QgdW5uZWNlc3NhcmlseSBkb3VibGUgdGhlIHdyYXBwZXJzLlxuXG52YXIgdmFsaWRhdGVTaGFyZWRQcm9wcyQxID0gZnVuY3Rpb24gdmFsaWRhdGVTaGFyZWRQcm9wcyhfcmVmMiwgX3JlZjMpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW4sXG4gICAgICBkaXJlY3Rpb24gPSBfcmVmMi5kaXJlY3Rpb24sXG4gICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQsXG4gICAgICBsYXlvdXQgPSBfcmVmMi5sYXlvdXQsXG4gICAgICBpbm5lclRhZ05hbWUgPSBfcmVmMi5pbm5lclRhZ05hbWUsXG4gICAgICBvdXRlclRhZ05hbWUgPSBfcmVmMi5vdXRlclRhZ05hbWUsXG4gICAgICB3aWR0aCA9IF9yZWYyLndpZHRoO1xuICB2YXIgaW5zdGFuY2UgPSBfcmVmMy5pbnN0YW5jZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChpbm5lclRhZ05hbWUgIT0gbnVsbCB8fCBvdXRlclRhZ05hbWUgIT0gbnVsbCkge1xuICAgICAgaWYgKGRldldhcm5pbmdzVGFnTmFtZSQxICYmICFkZXZXYXJuaW5nc1RhZ05hbWUkMS5oYXMoaW5zdGFuY2UpKSB7XG4gICAgICAgIGRldldhcm5pbmdzVGFnTmFtZSQxLmFkZChpbnN0YW5jZSk7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIGlubmVyVGFnTmFtZSBhbmQgb3V0ZXJUYWdOYW1lIHByb3BzIGhhdmUgYmVlbiBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgdGhlIGlubmVyRWxlbWVudFR5cGUgYW5kIG91dGVyRWxlbWVudFR5cGUgcHJvcHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICB9IC8vIFRPRE8gRGVwcmVjYXRlIGRpcmVjdGlvbiBcImhvcml6b250YWxcIlxuXG5cbiAgICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgfHwgbGF5b3V0ID09PSAnaG9yaXpvbnRhbCc7XG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIGlmIChkZXZXYXJuaW5nc0RpcmVjdGlvbiAmJiAhZGV2V2FybmluZ3NEaXJlY3Rpb24uaGFzKGluc3RhbmNlKSkge1xuICAgICAgICAgIGRldldhcm5pbmdzRGlyZWN0aW9uLmFkZChpbnN0YW5jZSk7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZGlyZWN0aW9uIHByb3Agc2hvdWxkIGJlIGVpdGhlciBcImx0clwiIChkZWZhdWx0KSBvciBcInJ0bFwiLiAnICsgJ1BsZWFzZSB1c2UgdGhlIGxheW91dCBwcm9wIHRvIHNwZWNpZnkgXCJ2ZXJ0aWNhbFwiIChkZWZhdWx0KSBvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsdHInOlxuICAgICAgY2FzZSAncnRsJzpcbiAgICAgICAgLy8gVmFsaWQgdmFsdWVzXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignQW4gaW52YWxpZCBcImRpcmVjdGlvblwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ1ZhbHVlIHNob3VsZCBiZSBlaXRoZXIgXCJsdHJcIiBvciBcInJ0bFwiLiAnICsgKFwiXFxcIlwiICsgZGlyZWN0aW9uICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGxheW91dCkge1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIC8vIFZhbGlkIHZhbHVlc1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0FuIGludmFsaWQgXCJsYXlvdXRcIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdWYWx1ZSBzaG91bGQgYmUgZWl0aGVyIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi4gJyArIChcIlxcXCJcIiArIGxheW91dCArIFwiXFxcIiB3YXMgc3BlY2lmaWVkLlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwiY2hpbGRyZW5cIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdWYWx1ZSBzaG91bGQgYmUgYSBSZWFjdCBjb21wb25lbnQuICcgKyAoXCJcXFwiXCIgKyAoY2hpbGRyZW4gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgY2hpbGRyZW4pICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNIb3Jpem9udGFsICYmIHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwid2lkdGhcIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdIb3Jpem9udGFsIGxpc3RzIG11c3Qgc3BlY2lmeSBhIG51bWJlciBmb3Igd2lkdGguICcgKyAoXCJcXFwiXCIgKyAod2lkdGggPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygd2lkdGgpICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICB9IGVsc2UgaWYgKCFpc0hvcml6b250YWwgJiYgdHlwZW9mIGhlaWdodCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwiaGVpZ2h0XCIgcHJvcCBoYXMgYmVlbiBzcGVjaWZpZWQuICcgKyAnVmVydGljYWwgbGlzdHMgbXVzdCBzcGVjaWZ5IGEgbnVtYmVyIGZvciBoZWlnaHQuICcgKyAoXCJcXFwiXCIgKyAoaGVpZ2h0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGhlaWdodCkgKyBcIlxcXCIgd2FzIHNwZWNpZmllZC5cIikpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIERFRkFVTFRfRVNUSU1BVEVEX0lURU1fU0laRSQxID0gNTA7XG5cbnZhciBnZXRJdGVtTWV0YWRhdGEkMSA9IGZ1bmN0aW9uIGdldEl0ZW1NZXRhZGF0YShwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpIHtcbiAgdmFyIF9yZWYgPSBwcm9wcyxcbiAgICAgIGl0ZW1TaXplID0gX3JlZi5pdGVtU2l6ZTtcbiAgdmFyIGl0ZW1NZXRhZGF0YU1hcCA9IGluc3RhbmNlUHJvcHMuaXRlbU1ldGFkYXRhTWFwLFxuICAgICAgbGFzdE1lYXN1cmVkSW5kZXggPSBpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZEluZGV4O1xuXG4gIGlmIChpbmRleCA+IGxhc3RNZWFzdXJlZEluZGV4KSB7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICBpZiAobGFzdE1lYXN1cmVkSW5kZXggPj0gMCkge1xuICAgICAgdmFyIGl0ZW1NZXRhZGF0YSA9IGl0ZW1NZXRhZGF0YU1hcFtsYXN0TWVhc3VyZWRJbmRleF07XG4gICAgICBvZmZzZXQgPSBpdGVtTWV0YWRhdGEub2Zmc2V0ICsgaXRlbU1ldGFkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IGxhc3RNZWFzdXJlZEluZGV4ICsgMTsgaSA8PSBpbmRleDsgaSsrKSB7XG4gICAgICB2YXIgc2l6ZSA9IGl0ZW1TaXplKGkpO1xuICAgICAgaXRlbU1ldGFkYXRhTWFwW2ldID0ge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgfTtcbiAgICAgIG9mZnNldCArPSBzaXplO1xuICAgIH1cblxuICAgIGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkSW5kZXggPSBpbmRleDtcbiAgfVxuXG4gIHJldHVybiBpdGVtTWV0YWRhdGFNYXBbaW5kZXhdO1xufTtcblxudmFyIGZpbmROZWFyZXN0SXRlbSQxID0gZnVuY3Rpb24gZmluZE5lYXJlc3RJdGVtKHByb3BzLCBpbnN0YW5jZVByb3BzLCBvZmZzZXQpIHtcbiAgdmFyIGl0ZW1NZXRhZGF0YU1hcCA9IGluc3RhbmNlUHJvcHMuaXRlbU1ldGFkYXRhTWFwLFxuICAgICAgbGFzdE1lYXN1cmVkSW5kZXggPSBpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZEluZGV4O1xuICB2YXIgbGFzdE1lYXN1cmVkSXRlbU9mZnNldCA9IGxhc3RNZWFzdXJlZEluZGV4ID4gMCA/IGl0ZW1NZXRhZGF0YU1hcFtsYXN0TWVhc3VyZWRJbmRleF0ub2Zmc2V0IDogMDtcblxuICBpZiAobGFzdE1lYXN1cmVkSXRlbU9mZnNldCA+PSBvZmZzZXQpIHtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IG1lYXN1cmVkIGl0ZW1zIHdpdGhpbiB0aGlzIHJhbmdlIGp1c3QgdXNlIGEgYmluYXJ5IHNlYXJjaCBhcyBpdCdzIGZhc3Rlci5cbiAgICByZXR1cm4gZmluZE5lYXJlc3RJdGVtQmluYXJ5U2VhcmNoJDEocHJvcHMsIGluc3RhbmNlUHJvcHMsIGxhc3RNZWFzdXJlZEluZGV4LCAwLCBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlIGhhdmVuJ3QgeWV0IG1lYXN1cmVkIHRoaXMgaGlnaCwgZmFsbGJhY2sgdG8gYW4gZXhwb25lbnRpYWwgc2VhcmNoIHdpdGggYW4gaW5uZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAvLyBUaGUgZXhwb25lbnRpYWwgc2VhcmNoIGF2b2lkcyBwcmUtY29tcHV0aW5nIHNpemVzIGZvciB0aGUgZnVsbCBzZXQgb2YgaXRlbXMgYXMgYSBiaW5hcnkgc2VhcmNoIHdvdWxkLlxuICAgIC8vIFRoZSBvdmVyYWxsIGNvbXBsZXhpdHkgZm9yIHRoaXMgYXBwcm9hY2ggaXMgTyhsb2cgbikuXG4gICAgcmV0dXJuIGZpbmROZWFyZXN0SXRlbUV4cG9uZW50aWFsU2VhcmNoJDEocHJvcHMsIGluc3RhbmNlUHJvcHMsIE1hdGgubWF4KDAsIGxhc3RNZWFzdXJlZEluZGV4KSwgb2Zmc2V0KTtcbiAgfVxufTtcblxudmFyIGZpbmROZWFyZXN0SXRlbUJpbmFyeVNlYXJjaCQxID0gZnVuY3Rpb24gZmluZE5lYXJlc3RJdGVtQmluYXJ5U2VhcmNoKHByb3BzLCBpbnN0YW5jZVByb3BzLCBoaWdoLCBsb3csIG9mZnNldCkge1xuICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICB2YXIgbWlkZGxlID0gbG93ICsgTWF0aC5mbG9vcigoaGlnaCAtIGxvdykgLyAyKTtcbiAgICB2YXIgY3VycmVudE9mZnNldCA9IGdldEl0ZW1NZXRhZGF0YSQxKHByb3BzLCBtaWRkbGUsIGluc3RhbmNlUHJvcHMpLm9mZnNldDtcblxuICAgIGlmIChjdXJyZW50T2Zmc2V0ID09PSBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudE9mZnNldCA+IG9mZnNldCkge1xuICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvdyA+IDApIHtcbiAgICByZXR1cm4gbG93IC0gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxudmFyIGZpbmROZWFyZXN0SXRlbUV4cG9uZW50aWFsU2VhcmNoJDEgPSBmdW5jdGlvbiBmaW5kTmVhcmVzdEl0ZW1FeHBvbmVudGlhbFNlYXJjaChwcm9wcywgaW5zdGFuY2VQcm9wcywgaW5kZXgsIG9mZnNldCkge1xuICB2YXIgaXRlbUNvdW50ID0gcHJvcHMuaXRlbUNvdW50O1xuICB2YXIgaW50ZXJ2YWwgPSAxO1xuXG4gIHdoaWxlIChpbmRleCA8IGl0ZW1Db3VudCAmJiBnZXRJdGVtTWV0YWRhdGEkMShwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpLm9mZnNldCA8IG9mZnNldCkge1xuICAgIGluZGV4ICs9IGludGVydmFsO1xuICAgIGludGVydmFsICo9IDI7XG4gIH1cblxuICByZXR1cm4gZmluZE5lYXJlc3RJdGVtQmluYXJ5U2VhcmNoJDEocHJvcHMsIGluc3RhbmNlUHJvcHMsIE1hdGgubWluKGluZGV4LCBpdGVtQ291bnQgLSAxKSwgTWF0aC5mbG9vcihpbmRleCAvIDIpLCBvZmZzZXQpO1xufTtcblxudmFyIGdldEVzdGltYXRlZFRvdGFsU2l6ZSA9IGZ1bmN0aW9uIGdldEVzdGltYXRlZFRvdGFsU2l6ZShfcmVmMiwgX3JlZjMpIHtcbiAgdmFyIGl0ZW1Db3VudCA9IF9yZWYyLml0ZW1Db3VudDtcbiAgdmFyIGl0ZW1NZXRhZGF0YU1hcCA9IF9yZWYzLml0ZW1NZXRhZGF0YU1hcCxcbiAgICAgIGVzdGltYXRlZEl0ZW1TaXplID0gX3JlZjMuZXN0aW1hdGVkSXRlbVNpemUsXG4gICAgICBsYXN0TWVhc3VyZWRJbmRleCA9IF9yZWYzLmxhc3RNZWFzdXJlZEluZGV4O1xuICB2YXIgdG90YWxTaXplT2ZNZWFzdXJlZEl0ZW1zID0gMDsgLy8gRWRnZSBjYXNlIGNoZWNrIGZvciB3aGVuIHRoZSBudW1iZXIgb2YgaXRlbXMgZGVjcmVhc2VzIHdoaWxlIGEgc2Nyb2xsIGlzIGluIHByb2dyZXNzLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnZhdWdobi9yZWFjdC13aW5kb3cvcHVsbC8xMzhcblxuICBpZiAobGFzdE1lYXN1cmVkSW5kZXggPj0gaXRlbUNvdW50KSB7XG4gICAgbGFzdE1lYXN1cmVkSW5kZXggPSBpdGVtQ291bnQgLSAxO1xuICB9XG5cbiAgaWYgKGxhc3RNZWFzdXJlZEluZGV4ID49IDApIHtcbiAgICB2YXIgaXRlbU1ldGFkYXRhID0gaXRlbU1ldGFkYXRhTWFwW2xhc3RNZWFzdXJlZEluZGV4XTtcbiAgICB0b3RhbFNpemVPZk1lYXN1cmVkSXRlbXMgPSBpdGVtTWV0YWRhdGEub2Zmc2V0ICsgaXRlbU1ldGFkYXRhLnNpemU7XG4gIH1cblxuICB2YXIgbnVtVW5tZWFzdXJlZEl0ZW1zID0gaXRlbUNvdW50IC0gbGFzdE1lYXN1cmVkSW5kZXggLSAxO1xuICB2YXIgdG90YWxTaXplT2ZVbm1lYXN1cmVkSXRlbXMgPSBudW1Vbm1lYXN1cmVkSXRlbXMgKiBlc3RpbWF0ZWRJdGVtU2l6ZTtcbiAgcmV0dXJuIHRvdGFsU2l6ZU9mTWVhc3VyZWRJdGVtcyArIHRvdGFsU2l6ZU9mVW5tZWFzdXJlZEl0ZW1zO1xufTtcblxudmFyIFZhcmlhYmxlU2l6ZUxpc3QgPSAvKiNfX1BVUkVfXyovY3JlYXRlTGlzdENvbXBvbmVudCh7XG4gIGdldEl0ZW1PZmZzZXQ6IGZ1bmN0aW9uIGdldEl0ZW1PZmZzZXQocHJvcHMsIGluZGV4LCBpbnN0YW5jZVByb3BzKSB7XG4gICAgcmV0dXJuIGdldEl0ZW1NZXRhZGF0YSQxKHByb3BzLCBpbmRleCwgaW5zdGFuY2VQcm9wcykub2Zmc2V0O1xuICB9LFxuICBnZXRJdGVtU2l6ZTogZnVuY3Rpb24gZ2V0SXRlbVNpemUocHJvcHMsIGluZGV4LCBpbnN0YW5jZVByb3BzKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlUHJvcHMuaXRlbU1ldGFkYXRhTWFwW2luZGV4XS5zaXplO1xuICB9LFxuICBnZXRFc3RpbWF0ZWRUb3RhbFNpemU6IGdldEVzdGltYXRlZFRvdGFsU2l6ZSxcbiAgZ2V0T2Zmc2V0Rm9ySW5kZXhBbmRBbGlnbm1lbnQ6IGZ1bmN0aW9uIGdldE9mZnNldEZvckluZGV4QW5kQWxpZ25tZW50KHByb3BzLCBpbmRleCwgYWxpZ24sIHNjcm9sbE9mZnNldCwgaW5zdGFuY2VQcm9wcywgc2Nyb2xsYmFyU2l6ZSkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBwcm9wcy5kaXJlY3Rpb24sXG4gICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICAgICAgbGF5b3V0ID0gcHJvcHMubGF5b3V0LFxuICAgICAgICB3aWR0aCA9IHByb3BzLndpZHRoOyAvLyBUT0RPIERlcHJlY2F0ZSBkaXJlY3Rpb24gXCJob3Jpem9udGFsXCJcblxuICAgIHZhciBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyB8fCBsYXlvdXQgPT09ICdob3Jpem9udGFsJztcbiAgICB2YXIgc2l6ZSA9IGlzSG9yaXpvbnRhbCA/IHdpZHRoIDogaGVpZ2h0O1xuICAgIHZhciBpdGVtTWV0YWRhdGEgPSBnZXRJdGVtTWV0YWRhdGEkMShwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpOyAvLyBHZXQgZXN0aW1hdGVkIHRvdGFsIHNpemUgYWZ0ZXIgSXRlbU1ldGFkYXRhIGlzIGNvbXB1dGVkLFxuICAgIC8vIFRvIGVuc3VyZSBpdCByZWZsZWN0cyBhY3R1YWwgbWVhc3VyZW1lbnRzIGluc3RlYWQgb2YganVzdCBlc3RpbWF0ZXMuXG5cbiAgICB2YXIgZXN0aW1hdGVkVG90YWxTaXplID0gZ2V0RXN0aW1hdGVkVG90YWxTaXplKHByb3BzLCBpbnN0YW5jZVByb3BzKTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZXN0aW1hdGVkVG90YWxTaXplIC0gc2l6ZSwgaXRlbU1ldGFkYXRhLm9mZnNldCkpO1xuICAgIHZhciBtaW5PZmZzZXQgPSBNYXRoLm1heCgwLCBpdGVtTWV0YWRhdGEub2Zmc2V0IC0gc2l6ZSArIGl0ZW1NZXRhZGF0YS5zaXplICsgc2Nyb2xsYmFyU2l6ZSk7XG5cbiAgICBpZiAoYWxpZ24gPT09ICdzbWFydCcpIHtcbiAgICAgIGlmIChzY3JvbGxPZmZzZXQgPj0gbWluT2Zmc2V0IC0gc2l6ZSAmJiBzY3JvbGxPZmZzZXQgPD0gbWF4T2Zmc2V0ICsgc2l6ZSkge1xuICAgICAgICBhbGlnbiA9ICdhdXRvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICByZXR1cm4gbWF4T2Zmc2V0O1xuXG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICByZXR1cm4gbWluT2Zmc2V0O1xuXG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtaW5PZmZzZXQgKyAobWF4T2Zmc2V0IC0gbWluT2Zmc2V0KSAvIDIpO1xuXG4gICAgICBjYXNlICdhdXRvJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzY3JvbGxPZmZzZXQgPj0gbWluT2Zmc2V0ICYmIHNjcm9sbE9mZnNldCA8PSBtYXhPZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2Nyb2xsT2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbE9mZnNldCA8IG1pbk9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBtaW5PZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1heE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9LFxuICBnZXRTdGFydEluZGV4Rm9yT2Zmc2V0OiBmdW5jdGlvbiBnZXRTdGFydEluZGV4Rm9yT2Zmc2V0KHByb3BzLCBvZmZzZXQsIGluc3RhbmNlUHJvcHMpIHtcbiAgICByZXR1cm4gZmluZE5lYXJlc3RJdGVtJDEocHJvcHMsIGluc3RhbmNlUHJvcHMsIG9mZnNldCk7XG4gIH0sXG4gIGdldFN0b3BJbmRleEZvclN0YXJ0SW5kZXg6IGZ1bmN0aW9uIGdldFN0b3BJbmRleEZvclN0YXJ0SW5kZXgocHJvcHMsIHN0YXJ0SW5kZXgsIHNjcm9sbE9mZnNldCwgaW5zdGFuY2VQcm9wcykge1xuICAgIHZhciBkaXJlY3Rpb24gPSBwcm9wcy5kaXJlY3Rpb24sXG4gICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICAgICAgaXRlbUNvdW50ID0gcHJvcHMuaXRlbUNvdW50LFxuICAgICAgICBsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXG4gICAgICAgIHdpZHRoID0gcHJvcHMud2lkdGg7IC8vIFRPRE8gRGVwcmVjYXRlIGRpcmVjdGlvbiBcImhvcml6b250YWxcIlxuXG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnIHx8IGxheW91dCA9PT0gJ2hvcml6b250YWwnO1xuICAgIHZhciBzaXplID0gaXNIb3Jpem9udGFsID8gd2lkdGggOiBoZWlnaHQ7XG4gICAgdmFyIGl0ZW1NZXRhZGF0YSA9IGdldEl0ZW1NZXRhZGF0YSQxKHByb3BzLCBzdGFydEluZGV4LCBpbnN0YW5jZVByb3BzKTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gc2Nyb2xsT2Zmc2V0ICsgc2l6ZTtcbiAgICB2YXIgb2Zmc2V0ID0gaXRlbU1ldGFkYXRhLm9mZnNldCArIGl0ZW1NZXRhZGF0YS5zaXplO1xuICAgIHZhciBzdG9wSW5kZXggPSBzdGFydEluZGV4O1xuXG4gICAgd2hpbGUgKHN0b3BJbmRleCA8IGl0ZW1Db3VudCAtIDEgJiYgb2Zmc2V0IDwgbWF4T2Zmc2V0KSB7XG4gICAgICBzdG9wSW5kZXgrKztcbiAgICAgIG9mZnNldCArPSBnZXRJdGVtTWV0YWRhdGEkMShwcm9wcywgc3RvcEluZGV4LCBpbnN0YW5jZVByb3BzKS5zaXplO1xuICAgIH1cblxuICAgIHJldHVybiBzdG9wSW5kZXg7XG4gIH0sXG4gIGluaXRJbnN0YW5jZVByb3BzOiBmdW5jdGlvbiBpbml0SW5zdGFuY2VQcm9wcyhwcm9wcywgaW5zdGFuY2UpIHtcbiAgICB2YXIgX3JlZjQgPSBwcm9wcyxcbiAgICAgICAgZXN0aW1hdGVkSXRlbVNpemUgPSBfcmVmNC5lc3RpbWF0ZWRJdGVtU2l6ZTtcbiAgICB2YXIgaW5zdGFuY2VQcm9wcyA9IHtcbiAgICAgIGl0ZW1NZXRhZGF0YU1hcDoge30sXG4gICAgICBlc3RpbWF0ZWRJdGVtU2l6ZTogZXN0aW1hdGVkSXRlbVNpemUgfHwgREVGQVVMVF9FU1RJTUFURURfSVRFTV9TSVpFJDEsXG4gICAgICBsYXN0TWVhc3VyZWRJbmRleDogLTFcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UucmVzZXRBZnRlckluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBzaG91bGRGb3JjZVVwZGF0ZSkge1xuICAgICAgaWYgKHNob3VsZEZvcmNlVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hvdWxkRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZEluZGV4ID0gTWF0aC5taW4oaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRJbmRleCwgaW5kZXggLSAxKTsgLy8gV2UgY291bGQgcG90ZW50aWFsbHkgb3B0aW1pemUgZnVydGhlciBieSBvbmx5IGV2aWN0aW5nIHN0eWxlcyBhZnRlciB0aGlzIGluZGV4LFxuICAgICAgLy8gQnV0IHNpbmNlIHN0eWxlcyBhcmUgb25seSBjYWNoZWQgd2hpbGUgc2Nyb2xsaW5nIGlzIGluIHByb2dyZXNzLVxuICAgICAgLy8gSXQgc2VlbXMgYW4gdW5uZWNlc3Nhcnkgb3B0aW1pemF0aW9uLlxuICAgICAgLy8gSXQncyB1bmxpa2VseSB0aGF0IHJlc2V0QWZ0ZXJJbmRleCgpIHdpbGwgYmUgY2FsbGVkIHdoaWxlIGEgdXNlciBpcyBzY3JvbGxpbmcuXG5cbiAgICAgIGluc3RhbmNlLl9nZXRJdGVtU3R5bGVDYWNoZSgtMSk7XG5cbiAgICAgIGlmIChzaG91bGRGb3JjZVVwZGF0ZSkge1xuICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gaW5zdGFuY2VQcm9wcztcbiAgfSxcbiAgc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZTogZmFsc2UsXG4gIHZhbGlkYXRlUHJvcHM6IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoX3JlZjUpIHtcbiAgICB2YXIgaXRlbVNpemUgPSBfcmVmNS5pdGVtU2l6ZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGl0ZW1TaXplICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwiaXRlbVNpemVcIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdWYWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbi4gJyArIChcIlxcXCJcIiArIChpdGVtU2l6ZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBpdGVtU2l6ZSkgKyBcIlxcXCIgd2FzIHNwZWNpZmllZC5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBGaXhlZFNpemVHcmlkID0gLyojX19QVVJFX18qL2NyZWF0ZUdyaWRDb21wb25lbnQoe1xuICBnZXRDb2x1bW5PZmZzZXQ6IGZ1bmN0aW9uIGdldENvbHVtbk9mZnNldChfcmVmLCBpbmRleCkge1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IF9yZWYuY29sdW1uV2lkdGg7XG4gICAgcmV0dXJuIGluZGV4ICogY29sdW1uV2lkdGg7XG4gIH0sXG4gIGdldENvbHVtbldpZHRoOiBmdW5jdGlvbiBnZXRDb2x1bW5XaWR0aChfcmVmMiwgaW5kZXgpIHtcbiAgICB2YXIgY29sdW1uV2lkdGggPSBfcmVmMi5jb2x1bW5XaWR0aDtcbiAgICByZXR1cm4gY29sdW1uV2lkdGg7XG4gIH0sXG4gIGdldFJvd09mZnNldDogZnVuY3Rpb24gZ2V0Um93T2Zmc2V0KF9yZWYzLCBpbmRleCkge1xuICAgIHZhciByb3dIZWlnaHQgPSBfcmVmMy5yb3dIZWlnaHQ7XG4gICAgcmV0dXJuIGluZGV4ICogcm93SGVpZ2h0O1xuICB9LFxuICBnZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uIGdldFJvd0hlaWdodChfcmVmNCwgaW5kZXgpIHtcbiAgICB2YXIgcm93SGVpZ2h0ID0gX3JlZjQucm93SGVpZ2h0O1xuICAgIHJldHVybiByb3dIZWlnaHQ7XG4gIH0sXG4gIGdldEVzdGltYXRlZFRvdGFsSGVpZ2h0OiBmdW5jdGlvbiBnZXRFc3RpbWF0ZWRUb3RhbEhlaWdodChfcmVmNSkge1xuICAgIHZhciByb3dDb3VudCA9IF9yZWY1LnJvd0NvdW50LFxuICAgICAgICByb3dIZWlnaHQgPSBfcmVmNS5yb3dIZWlnaHQ7XG4gICAgcmV0dXJuIHJvd0hlaWdodCAqIHJvd0NvdW50O1xuICB9LFxuICBnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoOiBmdW5jdGlvbiBnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoKF9yZWY2KSB7XG4gICAgdmFyIGNvbHVtbkNvdW50ID0gX3JlZjYuY29sdW1uQ291bnQsXG4gICAgICAgIGNvbHVtbldpZHRoID0gX3JlZjYuY29sdW1uV2lkdGg7XG4gICAgcmV0dXJuIGNvbHVtbldpZHRoICogY29sdW1uQ291bnQ7XG4gIH0sXG4gIGdldE9mZnNldEZvckNvbHVtbkFuZEFsaWdubWVudDogZnVuY3Rpb24gZ2V0T2Zmc2V0Rm9yQ29sdW1uQW5kQWxpZ25tZW50KF9yZWY3LCBjb2x1bW5JbmRleCwgYWxpZ24sIHNjcm9sbExlZnQsIGluc3RhbmNlUHJvcHMsIHNjcm9sbGJhclNpemUpIHtcbiAgICB2YXIgY29sdW1uQ291bnQgPSBfcmVmNy5jb2x1bW5Db3VudCxcbiAgICAgICAgY29sdW1uV2lkdGggPSBfcmVmNy5jb2x1bW5XaWR0aCxcbiAgICAgICAgd2lkdGggPSBfcmVmNy53aWR0aDtcbiAgICB2YXIgbGFzdENvbHVtbk9mZnNldCA9IE1hdGgubWF4KDAsIGNvbHVtbkNvdW50ICogY29sdW1uV2lkdGggLSB3aWR0aCk7XG4gICAgdmFyIG1heE9mZnNldCA9IE1hdGgubWluKGxhc3RDb2x1bW5PZmZzZXQsIGNvbHVtbkluZGV4ICogY29sdW1uV2lkdGgpO1xuICAgIHZhciBtaW5PZmZzZXQgPSBNYXRoLm1heCgwLCBjb2x1bW5JbmRleCAqIGNvbHVtbldpZHRoIC0gd2lkdGggKyBzY3JvbGxiYXJTaXplICsgY29sdW1uV2lkdGgpO1xuXG4gICAgaWYgKGFsaWduID09PSAnc21hcnQnKSB7XG4gICAgICBpZiAoc2Nyb2xsTGVmdCA+PSBtaW5PZmZzZXQgLSB3aWR0aCAmJiBzY3JvbGxMZWZ0IDw9IG1heE9mZnNldCArIHdpZHRoKSB7XG4gICAgICAgIGFsaWduID0gJ2F1dG8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIHJldHVybiBtYXhPZmZzZXQ7XG5cbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHJldHVybiBtaW5PZmZzZXQ7XG5cbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIC8vIFwiQ2VudGVyZWRcIiBvZmZzZXQgaXMgdXN1YWxseSB0aGUgYXZlcmFnZSBvZiB0aGUgbWluIGFuZCBtYXguXG4gICAgICAgIC8vIEJ1dCBuZWFyIHRoZSBlZGdlcyBvZiB0aGUgbGlzdCwgdGhpcyBkb2Vzbid0IGhvbGQgdHJ1ZS5cbiAgICAgICAgdmFyIG1pZGRsZU9mZnNldCA9IE1hdGgucm91bmQobWluT2Zmc2V0ICsgKG1heE9mZnNldCAtIG1pbk9mZnNldCkgLyAyKTtcblxuICAgICAgICBpZiAobWlkZGxlT2Zmc2V0IDwgTWF0aC5jZWlsKHdpZHRoIC8gMikpIHtcbiAgICAgICAgICByZXR1cm4gMDsgLy8gbmVhciB0aGUgYmVnaW5uaW5nXG4gICAgICAgIH0gZWxzZSBpZiAobWlkZGxlT2Zmc2V0ID4gbGFzdENvbHVtbk9mZnNldCArIE1hdGguZmxvb3Iod2lkdGggLyAyKSkge1xuICAgICAgICAgIHJldHVybiBsYXN0Q29sdW1uT2Zmc2V0OyAvLyBuZWFyIHRoZSBlbmRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWlkZGxlT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNjcm9sbExlZnQgPj0gbWluT2Zmc2V0ICYmIHNjcm9sbExlZnQgPD0gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNjcm9sbExlZnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobWluT2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSBvbmx5IHRha2UgaW50byBhY2NvdW50IHRoZSBzY3JvbGxiYXIgc2l6ZSB3aGVuIGNhbGN1bGF0aW5nIG1pbk9mZnNldFxuICAgICAgICAgIC8vIHRoaXMgdmFsdWUgY2FuIGJlIGxhcmdlciB0aGFuIG1heE9mZnNldCB3aGVuIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgICAgICByZXR1cm4gbWluT2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbExlZnQgPCBtaW5PZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gbWluT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtYXhPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfSxcbiAgZ2V0T2Zmc2V0Rm9yUm93QW5kQWxpZ25tZW50OiBmdW5jdGlvbiBnZXRPZmZzZXRGb3JSb3dBbmRBbGlnbm1lbnQoX3JlZjgsIHJvd0luZGV4LCBhbGlnbiwgc2Nyb2xsVG9wLCBpbnN0YW5jZVByb3BzLCBzY3JvbGxiYXJTaXplKSB7XG4gICAgdmFyIHJvd0hlaWdodCA9IF9yZWY4LnJvd0hlaWdodCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjguaGVpZ2h0LFxuICAgICAgICByb3dDb3VudCA9IF9yZWY4LnJvd0NvdW50O1xuICAgIHZhciBsYXN0Um93T2Zmc2V0ID0gTWF0aC5tYXgoMCwgcm93Q291bnQgKiByb3dIZWlnaHQgLSBoZWlnaHQpO1xuICAgIHZhciBtYXhPZmZzZXQgPSBNYXRoLm1pbihsYXN0Um93T2Zmc2V0LCByb3dJbmRleCAqIHJvd0hlaWdodCk7XG4gICAgdmFyIG1pbk9mZnNldCA9IE1hdGgubWF4KDAsIHJvd0luZGV4ICogcm93SGVpZ2h0IC0gaGVpZ2h0ICsgc2Nyb2xsYmFyU2l6ZSArIHJvd0hlaWdodCk7XG5cbiAgICBpZiAoYWxpZ24gPT09ICdzbWFydCcpIHtcbiAgICAgIGlmIChzY3JvbGxUb3AgPj0gbWluT2Zmc2V0IC0gaGVpZ2h0ICYmIHNjcm9sbFRvcCA8PSBtYXhPZmZzZXQgKyBoZWlnaHQpIHtcbiAgICAgICAgYWxpZ24gPSAnYXV0byc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgcmV0dXJuIG1heE9mZnNldDtcblxuICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgcmV0dXJuIG1pbk9mZnNldDtcblxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgLy8gXCJDZW50ZXJlZFwiIG9mZnNldCBpcyB1c3VhbGx5IHRoZSBhdmVyYWdlIG9mIHRoZSBtaW4gYW5kIG1heC5cbiAgICAgICAgLy8gQnV0IG5lYXIgdGhlIGVkZ2VzIG9mIHRoZSBsaXN0LCB0aGlzIGRvZXNuJ3QgaG9sZCB0cnVlLlxuICAgICAgICB2YXIgbWlkZGxlT2Zmc2V0ID0gTWF0aC5yb3VuZChtaW5PZmZzZXQgKyAobWF4T2Zmc2V0IC0gbWluT2Zmc2V0KSAvIDIpO1xuXG4gICAgICAgIGlmIChtaWRkbGVPZmZzZXQgPCBNYXRoLmNlaWwoaGVpZ2h0IC8gMikpIHtcbiAgICAgICAgICByZXR1cm4gMDsgLy8gbmVhciB0aGUgYmVnaW5uaW5nXG4gICAgICAgIH0gZWxzZSBpZiAobWlkZGxlT2Zmc2V0ID4gbGFzdFJvd09mZnNldCArIE1hdGguZmxvb3IoaGVpZ2h0IC8gMikpIHtcbiAgICAgICAgICByZXR1cm4gbGFzdFJvd09mZnNldDsgLy8gbmVhciB0aGUgZW5kXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1pZGRsZU9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdhdXRvJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzY3JvbGxUb3AgPj0gbWluT2Zmc2V0ICYmIHNjcm9sbFRvcCA8PSBtYXhPZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2Nyb2xsVG9wO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbk9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgIC8vIEJlY2F1c2Ugd2Ugb25seSB0YWtlIGludG8gYWNjb3VudCB0aGUgc2Nyb2xsYmFyIHNpemUgd2hlbiBjYWxjdWxhdGluZyBtaW5PZmZzZXRcbiAgICAgICAgICAvLyB0aGlzIHZhbHVlIGNhbiBiZSBsYXJnZXIgdGhhbiBtYXhPZmZzZXQgd2hlbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgICAgICAgcmV0dXJuIG1pbk9mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxUb3AgPCBtaW5PZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gbWluT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtYXhPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfSxcbiAgZ2V0Q29sdW1uU3RhcnRJbmRleEZvck9mZnNldDogZnVuY3Rpb24gZ2V0Q29sdW1uU3RhcnRJbmRleEZvck9mZnNldChfcmVmOSwgc2Nyb2xsTGVmdCkge1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IF9yZWY5LmNvbHVtbldpZHRoLFxuICAgICAgICBjb2x1bW5Db3VudCA9IF9yZWY5LmNvbHVtbkNvdW50O1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2x1bW5Db3VudCAtIDEsIE1hdGguZmxvb3Ioc2Nyb2xsTGVmdCAvIGNvbHVtbldpZHRoKSkpO1xuICB9LFxuICBnZXRDb2x1bW5TdG9wSW5kZXhGb3JTdGFydEluZGV4OiBmdW5jdGlvbiBnZXRDb2x1bW5TdG9wSW5kZXhGb3JTdGFydEluZGV4KF9yZWYxMCwgc3RhcnRJbmRleCwgc2Nyb2xsTGVmdCkge1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IF9yZWYxMC5jb2x1bW5XaWR0aCxcbiAgICAgICAgY29sdW1uQ291bnQgPSBfcmVmMTAuY29sdW1uQ291bnQsXG4gICAgICAgIHdpZHRoID0gX3JlZjEwLndpZHRoO1xuICAgIHZhciBsZWZ0ID0gc3RhcnRJbmRleCAqIGNvbHVtbldpZHRoO1xuICAgIHZhciBudW1WaXNpYmxlQ29sdW1ucyA9IE1hdGguY2VpbCgod2lkdGggKyBzY3JvbGxMZWZ0IC0gbGVmdCkgLyBjb2x1bW5XaWR0aCk7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKGNvbHVtbkNvdW50IC0gMSwgc3RhcnRJbmRleCArIG51bVZpc2libGVDb2x1bW5zIC0gMSAvLyAtMSBpcyBiZWNhdXNlIHN0b3AgaW5kZXggaXMgaW5jbHVzaXZlXG4gICAgKSk7XG4gIH0sXG4gIGdldFJvd1N0YXJ0SW5kZXhGb3JPZmZzZXQ6IGZ1bmN0aW9uIGdldFJvd1N0YXJ0SW5kZXhGb3JPZmZzZXQoX3JlZjExLCBzY3JvbGxUb3ApIHtcbiAgICB2YXIgcm93SGVpZ2h0ID0gX3JlZjExLnJvd0hlaWdodCxcbiAgICAgICAgcm93Q291bnQgPSBfcmVmMTEucm93Q291bnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHJvd0NvdW50IC0gMSwgTWF0aC5mbG9vcihzY3JvbGxUb3AgLyByb3dIZWlnaHQpKSk7XG4gIH0sXG4gIGdldFJvd1N0b3BJbmRleEZvclN0YXJ0SW5kZXg6IGZ1bmN0aW9uIGdldFJvd1N0b3BJbmRleEZvclN0YXJ0SW5kZXgoX3JlZjEyLCBzdGFydEluZGV4LCBzY3JvbGxUb3ApIHtcbiAgICB2YXIgcm93SGVpZ2h0ID0gX3JlZjEyLnJvd0hlaWdodCxcbiAgICAgICAgcm93Q291bnQgPSBfcmVmMTIucm93Q291bnQsXG4gICAgICAgIGhlaWdodCA9IF9yZWYxMi5oZWlnaHQ7XG4gICAgdmFyIHRvcCA9IHN0YXJ0SW5kZXggKiByb3dIZWlnaHQ7XG4gICAgdmFyIG51bVZpc2libGVSb3dzID0gTWF0aC5jZWlsKChoZWlnaHQgKyBzY3JvbGxUb3AgLSB0b3ApIC8gcm93SGVpZ2h0KTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4ocm93Q291bnQgLSAxLCBzdGFydEluZGV4ICsgbnVtVmlzaWJsZVJvd3MgLSAxIC8vIC0xIGlzIGJlY2F1c2Ugc3RvcCBpbmRleCBpcyBpbmNsdXNpdmVcbiAgICApKTtcbiAgfSxcbiAgaW5pdEluc3RhbmNlUHJvcHM6IGZ1bmN0aW9uIGluaXRJbnN0YW5jZVByb3BzKHByb3BzKSB7Ly8gTm9vcFxuICB9LFxuICBzaG91bGRSZXNldFN0eWxlQ2FjaGVPbkl0ZW1TaXplQ2hhbmdlOiB0cnVlLFxuICB2YWxpZGF0ZVByb3BzOiBmdW5jdGlvbiB2YWxpZGF0ZVByb3BzKF9yZWYxMykge1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IF9yZWYxMy5jb2x1bW5XaWR0aCxcbiAgICAgICAgcm93SGVpZ2h0ID0gX3JlZjEzLnJvd0hlaWdodDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbHVtbldpZHRoICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcignQW4gaW52YWxpZCBcImNvbHVtbldpZHRoXCIgcHJvcCBoYXMgYmVlbiBzcGVjaWZpZWQuICcgKyAnVmFsdWUgc2hvdWxkIGJlIGEgbnVtYmVyLiAnICsgKFwiXFxcIlwiICsgKGNvbHVtbldpZHRoID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGNvbHVtbldpZHRoKSArIFwiXFxcIiB3YXMgc3BlY2lmaWVkLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcignQW4gaW52YWxpZCBcInJvd0hlaWdodFwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ1ZhbHVlIHNob3VsZCBiZSBhIG51bWJlci4gJyArIChcIlxcXCJcIiArIChyb3dIZWlnaHQgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygcm93SGVpZ2h0KSArIFwiXFxcIiB3YXMgc3BlY2lmaWVkLlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIEZpeGVkU2l6ZUxpc3QgPSAvKiNfX1BVUkVfXyovY3JlYXRlTGlzdENvbXBvbmVudCh7XG4gIGdldEl0ZW1PZmZzZXQ6IGZ1bmN0aW9uIGdldEl0ZW1PZmZzZXQoX3JlZiwgaW5kZXgpIHtcbiAgICB2YXIgaXRlbVNpemUgPSBfcmVmLml0ZW1TaXplO1xuICAgIHJldHVybiBpbmRleCAqIGl0ZW1TaXplO1xuICB9LFxuICBnZXRJdGVtU2l6ZTogZnVuY3Rpb24gZ2V0SXRlbVNpemUoX3JlZjIsIGluZGV4KSB7XG4gICAgdmFyIGl0ZW1TaXplID0gX3JlZjIuaXRlbVNpemU7XG4gICAgcmV0dXJuIGl0ZW1TaXplO1xuICB9LFxuICBnZXRFc3RpbWF0ZWRUb3RhbFNpemU6IGZ1bmN0aW9uIGdldEVzdGltYXRlZFRvdGFsU2l6ZShfcmVmMykge1xuICAgIHZhciBpdGVtQ291bnQgPSBfcmVmMy5pdGVtQ291bnQsXG4gICAgICAgIGl0ZW1TaXplID0gX3JlZjMuaXRlbVNpemU7XG4gICAgcmV0dXJuIGl0ZW1TaXplICogaXRlbUNvdW50O1xuICB9LFxuICBnZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudDogZnVuY3Rpb24gZ2V0T2Zmc2V0Rm9ySW5kZXhBbmRBbGlnbm1lbnQoX3JlZjQsIGluZGV4LCBhbGlnbiwgc2Nyb2xsT2Zmc2V0LCBpbnN0YW5jZVByb3BzLCBzY3JvbGxiYXJTaXplKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IF9yZWY0LmRpcmVjdGlvbixcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjQuaGVpZ2h0LFxuICAgICAgICBpdGVtQ291bnQgPSBfcmVmNC5pdGVtQ291bnQsXG4gICAgICAgIGl0ZW1TaXplID0gX3JlZjQuaXRlbVNpemUsXG4gICAgICAgIGxheW91dCA9IF9yZWY0LmxheW91dCxcbiAgICAgICAgd2lkdGggPSBfcmVmNC53aWR0aDtcbiAgICAvLyBUT0RPIERlcHJlY2F0ZSBkaXJlY3Rpb24gXCJob3Jpem9udGFsXCJcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgfHwgbGF5b3V0ID09PSAnaG9yaXpvbnRhbCc7XG4gICAgdmFyIHNpemUgPSBpc0hvcml6b250YWwgPyB3aWR0aCA6IGhlaWdodDtcbiAgICB2YXIgbGFzdEl0ZW1PZmZzZXQgPSBNYXRoLm1heCgwLCBpdGVtQ291bnQgKiBpdGVtU2l6ZSAtIHNpemUpO1xuICAgIHZhciBtYXhPZmZzZXQgPSBNYXRoLm1pbihsYXN0SXRlbU9mZnNldCwgaW5kZXggKiBpdGVtU2l6ZSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IE1hdGgubWF4KDAsIGluZGV4ICogaXRlbVNpemUgLSBzaXplICsgaXRlbVNpemUgKyBzY3JvbGxiYXJTaXplKTtcblxuICAgIGlmIChhbGlnbiA9PT0gJ3NtYXJ0Jykge1xuICAgICAgaWYgKHNjcm9sbE9mZnNldCA+PSBtaW5PZmZzZXQgLSBzaXplICYmIHNjcm9sbE9mZnNldCA8PSBtYXhPZmZzZXQgKyBzaXplKSB7XG4gICAgICAgIGFsaWduID0gJ2F1dG8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIHJldHVybiBtYXhPZmZzZXQ7XG5cbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHJldHVybiBtaW5PZmZzZXQ7XG5cbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBcIkNlbnRlcmVkXCIgb2Zmc2V0IGlzIHVzdWFsbHkgdGhlIGF2ZXJhZ2Ugb2YgdGhlIG1pbiBhbmQgbWF4LlxuICAgICAgICAgIC8vIEJ1dCBuZWFyIHRoZSBlZGdlcyBvZiB0aGUgbGlzdCwgdGhpcyBkb2Vzbid0IGhvbGQgdHJ1ZS5cbiAgICAgICAgICB2YXIgbWlkZGxlT2Zmc2V0ID0gTWF0aC5yb3VuZChtaW5PZmZzZXQgKyAobWF4T2Zmc2V0IC0gbWluT2Zmc2V0KSAvIDIpO1xuXG4gICAgICAgICAgaWYgKG1pZGRsZU9mZnNldCA8IE1hdGguY2VpbChzaXplIC8gMikpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBuZWFyIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICB9IGVsc2UgaWYgKG1pZGRsZU9mZnNldCA+IGxhc3RJdGVtT2Zmc2V0ICsgTWF0aC5mbG9vcihzaXplIC8gMikpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0SXRlbU9mZnNldDsgLy8gbmVhciB0aGUgZW5kXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtaWRkbGVPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNjcm9sbE9mZnNldCA+PSBtaW5PZmZzZXQgJiYgc2Nyb2xsT2Zmc2V0IDw9IG1heE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBzY3JvbGxPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIG1pbk9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICB9XG4gIH0sXG4gIGdldFN0YXJ0SW5kZXhGb3JPZmZzZXQ6IGZ1bmN0aW9uIGdldFN0YXJ0SW5kZXhGb3JPZmZzZXQoX3JlZjUsIG9mZnNldCkge1xuICAgIHZhciBpdGVtQ291bnQgPSBfcmVmNS5pdGVtQ291bnQsXG4gICAgICAgIGl0ZW1TaXplID0gX3JlZjUuaXRlbVNpemU7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKGl0ZW1Db3VudCAtIDEsIE1hdGguZmxvb3Iob2Zmc2V0IC8gaXRlbVNpemUpKSk7XG4gIH0sXG4gIGdldFN0b3BJbmRleEZvclN0YXJ0SW5kZXg6IGZ1bmN0aW9uIGdldFN0b3BJbmRleEZvclN0YXJ0SW5kZXgoX3JlZjYsIHN0YXJ0SW5kZXgsIHNjcm9sbE9mZnNldCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBfcmVmNi5kaXJlY3Rpb24sXG4gICAgICAgIGhlaWdodCA9IF9yZWY2LmhlaWdodCxcbiAgICAgICAgaXRlbUNvdW50ID0gX3JlZjYuaXRlbUNvdW50LFxuICAgICAgICBpdGVtU2l6ZSA9IF9yZWY2Lml0ZW1TaXplLFxuICAgICAgICBsYXlvdXQgPSBfcmVmNi5sYXlvdXQsXG4gICAgICAgIHdpZHRoID0gX3JlZjYud2lkdGg7XG4gICAgLy8gVE9ETyBEZXByZWNhdGUgZGlyZWN0aW9uIFwiaG9yaXpvbnRhbFwiXG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnIHx8IGxheW91dCA9PT0gJ2hvcml6b250YWwnO1xuICAgIHZhciBvZmZzZXQgPSBzdGFydEluZGV4ICogaXRlbVNpemU7XG4gICAgdmFyIHNpemUgPSBpc0hvcml6b250YWwgPyB3aWR0aCA6IGhlaWdodDtcbiAgICB2YXIgbnVtVmlzaWJsZUl0ZW1zID0gTWF0aC5jZWlsKChzaXplICsgc2Nyb2xsT2Zmc2V0IC0gb2Zmc2V0KSAvIGl0ZW1TaXplKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oaXRlbUNvdW50IC0gMSwgc3RhcnRJbmRleCArIG51bVZpc2libGVJdGVtcyAtIDEgLy8gLTEgaXMgYmVjYXVzZSBzdG9wIGluZGV4IGlzIGluY2x1c2l2ZVxuICAgICkpO1xuICB9LFxuICBpbml0SW5zdGFuY2VQcm9wczogZnVuY3Rpb24gaW5pdEluc3RhbmNlUHJvcHMocHJvcHMpIHsvLyBOb29wXG4gIH0sXG4gIHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2U6IHRydWUsXG4gIHZhbGlkYXRlUHJvcHM6IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoX3JlZjcpIHtcbiAgICB2YXIgaXRlbVNpemUgPSBfcmVmNy5pdGVtU2l6ZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGl0ZW1TaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcignQW4gaW52YWxpZCBcIml0ZW1TaXplXCIgcHJvcCBoYXMgYmVlbiBzcGVjaWZpZWQuICcgKyAnVmFsdWUgc2hvdWxkIGJlIGEgbnVtYmVyLiAnICsgKFwiXFxcIlwiICsgKGl0ZW1TaXplID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGl0ZW1TaXplKSArIFwiXFxcIiB3YXMgc3BlY2lmaWVkLlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuLy8gUHVsbGVkIGZyb20gcmVhY3QtY29tcGF0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC1jb21wYXQvYmxvYi83YzVkZTAwZTdjODVlMmZmZDAxMWJmM2FmMDI4OTliNjNmNjk5ZDNhL3NyYy9pbmRleC5qcyNMMzQ5XG5mdW5jdGlvbiBzaGFsbG93RGlmZmVycyhwcmV2LCBuZXh0KSB7XG4gIGZvciAodmFyIGF0dHJpYnV0ZSBpbiBwcmV2KSB7XG4gICAgaWYgKCEoYXR0cmlidXRlIGluIG5leHQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfYXR0cmlidXRlIGluIG5leHQpIHtcbiAgICBpZiAocHJldltfYXR0cmlidXRlXSAhPT0gbmV4dFtfYXR0cmlidXRlXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wic3R5bGVcIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcInN0eWxlXCJdO1xuLy8gSXQga25vd3MgdG8gY29tcGFyZSBpbmRpdmlkdWFsIHN0eWxlIHByb3BzIGFuZCBpZ25vcmUgdGhlIHdyYXBwZXIgb2JqZWN0LlxuLy8gU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdG1lbW9cblxuZnVuY3Rpb24gYXJlRXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgdmFyIHByZXZTdHlsZSA9IHByZXZQcm9wcy5zdHlsZSxcbiAgICAgIHByZXZSZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJldlByb3BzLCBfZXhjbHVkZWQpO1xuXG4gIHZhciBuZXh0U3R5bGUgPSBuZXh0UHJvcHMuc3R5bGUsXG4gICAgICBuZXh0UmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKG5leHRQcm9wcywgX2V4Y2x1ZGVkMik7XG5cbiAgcmV0dXJuICFzaGFsbG93RGlmZmVycyhwcmV2U3R5bGUsIG5leHRTdHlsZSkgJiYgIXNoYWxsb3dEaWZmZXJzKHByZXZSZXN0LCBuZXh0UmVzdCk7XG59XG5cbi8vIEl0IGtub3dzIHRvIGNvbXBhcmUgaW5kaXZpZHVhbCBzdHlsZSBwcm9wcyBhbmQgaWdub3JlIHRoZSB3cmFwcGVyIG9iamVjdC5cbi8vIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtY29tcG9uZW50Lmh0bWwjc2hvdWxkY29tcG9uZW50dXBkYXRlXG5cbmZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICByZXR1cm4gIWFyZUVxdWFsKHRoaXMucHJvcHMsIG5leHRQcm9wcykgfHwgc2hhbGxvd0RpZmZlcnModGhpcy5zdGF0ZSwgbmV4dFN0YXRlKTtcbn1cblxuZXhwb3J0IHsgRml4ZWRTaXplR3JpZCwgRml4ZWRTaXplTGlzdCwgVmFyaWFibGVTaXplR3JpZCwgVmFyaWFibGVTaXplTGlzdCwgYXJlRXF1YWwsIHNob3VsZENvbXBvbmVudFVwZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIl9pbmhlcml0c0xvb3NlIiwibWVtb2l6ZU9uZSIsImNyZWF0ZUVsZW1lbnQiLCJQdXJlQ29tcG9uZW50IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsImNhbmNlbFRpbWVvdXQiLCJ0aW1lb3V0SUQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlkIiwicmVxdWVzdFRpbWVvdXQiLCJjYWxsYmFjayIsImRlbGF5Iiwic3RhcnQiLCJ0aWNrIiwiY2FsbCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNpemUiLCJnZXRTY3JvbGxiYXJTaXplIiwicmVjYWxjdWxhdGUiLCJkaXYiLCJkb2N1bWVudCIsInN0eWxlIiwid2lkdGgiLCJoZWlnaHQiLCJvdmVyZmxvdyIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIm9mZnNldFdpZHRoIiwiY2xpZW50V2lkdGgiLCJyZW1vdmVDaGlsZCIsImNhY2hlZFJUTFJlc3VsdCIsImdldFJUTE9mZnNldFR5cGUiLCJvdXRlckRpdiIsIm91dGVyU3R5bGUiLCJkaXJlY3Rpb24iLCJpbm5lckRpdiIsImlubmVyU3R5bGUiLCJzY3JvbGxMZWZ0IiwiSVNfU0NST0xMSU5HX0RFQk9VTkNFX0lOVEVSVkFMIiwiZGVmYXVsdEl0ZW1LZXkiLCJfcmVmIiwiY29sdW1uSW5kZXgiLCJkYXRhIiwicm93SW5kZXgiLCJkZXZXYXJuaW5nc092ZXJzY2FuQ291bnQiLCJkZXZXYXJuaW5nc092ZXJzY2FuUm93c0NvbHVtbnNDb3VudCIsImRldldhcm5pbmdzVGFnTmFtZSIsInByb2Nlc3MiLCJ3aW5kb3ciLCJXZWFrU2V0IiwiY3JlYXRlR3JpZENvbXBvbmVudCIsIl9yZWYyIiwiX2NsYXNzIiwiZ2V0Q29sdW1uT2Zmc2V0IiwiZ2V0Q29sdW1uU3RhcnRJbmRleEZvck9mZnNldCIsImdldENvbHVtblN0b3BJbmRleEZvclN0YXJ0SW5kZXgiLCJnZXRDb2x1bW5XaWR0aCIsImdldEVzdGltYXRlZFRvdGFsSGVpZ2h0IiwiZ2V0RXN0aW1hdGVkVG90YWxXaWR0aCIsImdldE9mZnNldEZvckNvbHVtbkFuZEFsaWdubWVudCIsImdldE9mZnNldEZvclJvd0FuZEFsaWdubWVudCIsImdldFJvd0hlaWdodCIsImdldFJvd09mZnNldCIsImdldFJvd1N0YXJ0SW5kZXhGb3JPZmZzZXQiLCJnZXRSb3dTdG9wSW5kZXhGb3JTdGFydEluZGV4IiwiaW5pdEluc3RhbmNlUHJvcHMiLCJzaG91bGRSZXNldFN0eWxlQ2FjaGVPbkl0ZW1TaXplQ2hhbmdlIiwidmFsaWRhdGVQcm9wcyIsIl9QdXJlQ29tcG9uZW50IiwiR3JpZCIsInByb3BzIiwiX3RoaXMiLCJfaW5zdGFuY2VQcm9wcyIsIl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkIiwiX291dGVyUmVmIiwic3RhdGUiLCJpbnN0YW5jZSIsImlzU2Nyb2xsaW5nIiwiaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiIsImluaXRpYWxTY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiaW5pdGlhbFNjcm9sbFRvcCIsInNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCIsInZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uIiwiX2NhbGxPbkl0ZW1zUmVuZGVyZWQiLCJvdmVyc2NhbkNvbHVtblN0YXJ0SW5kZXgiLCJvdmVyc2NhbkNvbHVtblN0b3BJbmRleCIsIm92ZXJzY2FuUm93U3RhcnRJbmRleCIsIm92ZXJzY2FuUm93U3RvcEluZGV4IiwidmlzaWJsZUNvbHVtblN0YXJ0SW5kZXgiLCJ2aXNpYmxlQ29sdW1uU3RvcEluZGV4IiwidmlzaWJsZVJvd1N0YXJ0SW5kZXgiLCJ2aXNpYmxlUm93U3RvcEluZGV4Iiwib25JdGVtc1JlbmRlcmVkIiwiX2NhbGxPblNjcm9sbCIsIm9uU2Nyb2xsIiwiX2dldEl0ZW1TdHlsZSIsIl90aGlzJHByb3BzIiwiY29sdW1uV2lkdGgiLCJyb3dIZWlnaHQiLCJpdGVtU3R5bGVDYWNoZSIsIl9nZXRJdGVtU3R5bGVDYWNoZSIsImtleSIsImhhc093blByb3BlcnR5IiwiX29mZnNldCIsImlzUnRsIiwicG9zaXRpb24iLCJsZWZ0IiwidW5kZWZpbmVkIiwicmlnaHQiLCJ0b3AiLCJfIiwiX18iLCJfX18iLCJfb25TY3JvbGwiLCJldmVudCIsIl9ldmVudCRjdXJyZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsInNjcm9sbFdpZHRoIiwic2V0U3RhdGUiLCJwcmV2U3RhdGUiLCJjYWxjdWxhdGVkU2Nyb2xsTGVmdCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJjYWxjdWxhdGVkU2Nyb2xsVG9wIiwiX3Jlc2V0SXNTY3JvbGxpbmdEZWJvdW5jZWQiLCJfb3V0ZXJSZWZTZXR0ZXIiLCJyZWYiLCJvdXRlclJlZiIsImN1cnJlbnQiLCJfcmVzZXRJc1Njcm9sbGluZyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInZhbGlkYXRlU2hhcmVkUHJvcHMiLCJfcHJvdG8iLCJwcm90b3R5cGUiLCJzY3JvbGxUbyIsIl9yZWYzIiwic2Nyb2xsVG9JdGVtIiwiX3JlZjQiLCJfcmVmNCRhbGlnbiIsImFsaWduIiwiX3RoaXMkcHJvcHMyIiwiY29sdW1uQ291bnQiLCJyb3dDb3VudCIsIl90aGlzJHN0YXRlIiwic2Nyb2xsYmFyU2l6ZSIsImVzdGltYXRlZFRvdGFsSGVpZ2h0IiwiZXN0aW1hdGVkVG90YWxXaWR0aCIsImhvcml6b250YWxTY3JvbGxiYXJTaXplIiwidmVydGljYWxTY3JvbGxiYXJTaXplIiwiY29tcG9uZW50RGlkTW91bnQiLCJfdGhpcyRwcm9wczMiLCJfY2FsbFByb3BzQ2FsbGJhY2tzIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiX3RoaXMkc3RhdGUyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW5kZXIiLCJfdGhpcyRwcm9wczQiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImlubmVyUmVmIiwiaW5uZXJFbGVtZW50VHlwZSIsImlubmVyVGFnTmFtZSIsIml0ZW1EYXRhIiwiX3RoaXMkcHJvcHM0JGl0ZW1LZXkiLCJpdGVtS2V5Iiwib3V0ZXJFbGVtZW50VHlwZSIsIm91dGVyVGFnTmFtZSIsInVzZUlzU2Nyb2xsaW5nIiwiX3RoaXMkX2dldEhvcml6b250YWxSIiwiX2dldEhvcml6b250YWxSYW5nZVRvUmVuZGVyIiwiY29sdW1uU3RhcnRJbmRleCIsImNvbHVtblN0b3BJbmRleCIsIl90aGlzJF9nZXRWZXJ0aWNhbFJhbiIsIl9nZXRWZXJ0aWNhbFJhbmdlVG9SZW5kZXIiLCJyb3dTdGFydEluZGV4Iiwicm93U3RvcEluZGV4IiwiaXRlbXMiLCJfcm93SW5kZXgiLCJfY29sdW1uSW5kZXgiLCJwdXNoIiwiV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmciLCJ3aWxsQ2hhbmdlIiwicG9pbnRlckV2ZW50cyIsIl90aGlzJHByb3BzNSIsIl90aGlzJF9nZXRIb3Jpem9udGFsUjIiLCJfb3ZlcnNjYW5Db2x1bW5TdGFydEluZGV4IiwiX292ZXJzY2FuQ29sdW1uU3RvcEluZGV4IiwiX3Zpc2libGVDb2x1bW5TdGFydEluZGV4IiwiX3Zpc2libGVDb2x1bW5TdG9wSW5kZXgiLCJfdGhpcyRfZ2V0VmVydGljYWxSYW4yIiwiX292ZXJzY2FuUm93U3RhcnRJbmRleCIsIl9vdmVyc2NhblJvd1N0b3BJbmRleCIsIl92aXNpYmxlUm93U3RhcnRJbmRleCIsIl92aXNpYmxlUm93U3RvcEluZGV4IiwiX3RoaXMkc3RhdGUzIiwiX2hvcml6b250YWxTY3JvbGxEaXJlY3Rpb24iLCJfc2Nyb2xsTGVmdCIsIl9zY3JvbGxUb3AiLCJfc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkIiwiX3ZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uIiwiX3RoaXMkcHJvcHM2Iiwib3ZlcnNjYW5Db2x1bW5Db3VudCIsIm92ZXJzY2FuQ29sdW1uc0NvdW50Iiwib3ZlcnNjYW5Db3VudCIsIl90aGlzJHN0YXRlNCIsIm92ZXJzY2FuQ291bnRSZXNvbHZlZCIsInN0YXJ0SW5kZXgiLCJzdG9wSW5kZXgiLCJvdmVyc2NhbkJhY2t3YXJkIiwib3ZlcnNjYW5Gb3J3YXJkIiwiX3RoaXMkcHJvcHM3Iiwib3ZlcnNjYW5Sb3dDb3VudCIsIm92ZXJzY2FuUm93c0NvdW50IiwiX3RoaXMkc3RhdGU1IiwiZGVmYXVsdFByb3BzIiwiX3JlZjUiLCJfcmVmNiIsImhhcyIsImFkZCIsImNvbnNvbGUiLCJ3YXJuIiwiRXJyb3IiLCJERUZBVUxUX0VTVElNQVRFRF9JVEVNX1NJWkUiLCJyb3dNZXRhZGF0YU1hcCIsImVzdGltYXRlZFJvd0hlaWdodCIsImxhc3RNZWFzdXJlZFJvd0luZGV4IiwidG90YWxTaXplT2ZNZWFzdXJlZFJvd3MiLCJpdGVtTWV0YWRhdGEiLCJvZmZzZXQiLCJudW1Vbm1lYXN1cmVkSXRlbXMiLCJ0b3RhbFNpemVPZlVubWVhc3VyZWRJdGVtcyIsImNvbHVtbk1ldGFkYXRhTWFwIiwiZXN0aW1hdGVkQ29sdW1uV2lkdGgiLCJsYXN0TWVhc3VyZWRDb2x1bW5JbmRleCIsImdldEl0ZW1NZXRhZGF0YSIsIml0ZW1UeXBlIiwiaW5kZXgiLCJpbnN0YW5jZVByb3BzIiwiaXRlbU1ldGFkYXRhTWFwIiwiaXRlbVNpemUiLCJsYXN0TWVhc3VyZWRJbmRleCIsImkiLCJmaW5kTmVhcmVzdEl0ZW0iLCJsYXN0TWVhc3VyZWRJdGVtT2Zmc2V0IiwiZmluZE5lYXJlc3RJdGVtQmluYXJ5U2VhcmNoIiwiZmluZE5lYXJlc3RJdGVtRXhwb25lbnRpYWxTZWFyY2giLCJoaWdoIiwibG93IiwibWlkZGxlIiwiZmxvb3IiLCJjdXJyZW50T2Zmc2V0IiwiaXRlbUNvdW50IiwiaW50ZXJ2YWwiLCJnZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudCIsInNjcm9sbE9mZnNldCIsImVzdGltYXRlZFRvdGFsU2l6ZSIsIm1heE9mZnNldCIsIm1pbk9mZnNldCIsInJvdW5kIiwiVmFyaWFibGVTaXplR3JpZCIsInJlc2V0QWZ0ZXJDb2x1bW5JbmRleCIsInNob3VsZEZvcmNlVXBkYXRlIiwicmVzZXRBZnRlckluZGljZXMiLCJyZXNldEFmdGVyUm93SW5kZXgiLCJfcmVmNiRzaG91bGRGb3JjZVVwZGEiLCJmb3JjZVVwZGF0ZSIsIl9yZWY3IiwiSVNfU0NST0xMSU5HX0RFQk9VTkNFX0lOVEVSVkFMJDEiLCJkZWZhdWx0SXRlbUtleSQxIiwiZGV2V2FybmluZ3NEaXJlY3Rpb24iLCJkZXZXYXJuaW5nc1RhZ05hbWUkMSIsImNyZWF0ZUxpc3RDb21wb25lbnQiLCJnZXRJdGVtT2Zmc2V0IiwiZ2V0RXN0aW1hdGVkVG90YWxTaXplIiwiZ2V0SXRlbVNpemUiLCJnZXRTdGFydEluZGV4Rm9yT2Zmc2V0IiwiZ2V0U3RvcEluZGV4Rm9yU3RhcnRJbmRleCIsIkxpc3QiLCJzY3JvbGxEaXJlY3Rpb24iLCJpbml0aWFsU2Nyb2xsT2Zmc2V0Iiwib3ZlcnNjYW5TdGFydEluZGV4Iiwib3ZlcnNjYW5TdG9wSW5kZXgiLCJ2aXNpYmxlU3RhcnRJbmRleCIsInZpc2libGVTdG9wSW5kZXgiLCJsYXlvdXQiLCJpc0hvcml6b250YWwiLCJvZmZzZXRIb3Jpem9udGFsIiwiX29uU2Nyb2xsSG9yaXpvbnRhbCIsIl9vblNjcm9sbFZlcnRpY2FsIiwiX2V2ZW50JGN1cnJlbnRUYXJnZXQyIiwidmFsaWRhdGVTaGFyZWRQcm9wcyQxIiwiX3RoaXMkcHJvcHM1JGl0ZW1LZXkiLCJfdGhpcyRfZ2V0UmFuZ2VUb1JlbmQiLCJfZ2V0UmFuZ2VUb1JlbmRlciIsIl9pbmRleCIsIl90aGlzJF9nZXRSYW5nZVRvUmVuZDIiLCJfb3ZlcnNjYW5TdGFydEluZGV4IiwiX292ZXJzY2FuU3RvcEluZGV4IiwiX3Zpc2libGVTdGFydEluZGV4IiwiX3Zpc2libGVTdG9wSW5kZXgiLCJfc2Nyb2xsRGlyZWN0aW9uIiwiX3Njcm9sbE9mZnNldCIsIkRFRkFVTFRfRVNUSU1BVEVEX0lURU1fU0laRSQxIiwiZ2V0SXRlbU1ldGFkYXRhJDEiLCJmaW5kTmVhcmVzdEl0ZW0kMSIsImZpbmROZWFyZXN0SXRlbUJpbmFyeVNlYXJjaCQxIiwiZmluZE5lYXJlc3RJdGVtRXhwb25lbnRpYWxTZWFyY2gkMSIsImVzdGltYXRlZEl0ZW1TaXplIiwidG90YWxTaXplT2ZNZWFzdXJlZEl0ZW1zIiwiVmFyaWFibGVTaXplTGlzdCIsInJlc2V0QWZ0ZXJJbmRleCIsIkZpeGVkU2l6ZUdyaWQiLCJsYXN0Q29sdW1uT2Zmc2V0IiwibWlkZGxlT2Zmc2V0IiwiY2VpbCIsIl9yZWY4IiwibGFzdFJvd09mZnNldCIsIl9yZWY5IiwiX3JlZjEwIiwibnVtVmlzaWJsZUNvbHVtbnMiLCJfcmVmMTEiLCJfcmVmMTIiLCJudW1WaXNpYmxlUm93cyIsIl9yZWYxMyIsIkZpeGVkU2l6ZUxpc3QiLCJsYXN0SXRlbU9mZnNldCIsIm51bVZpc2libGVJdGVtcyIsInNoYWxsb3dEaWZmZXJzIiwicHJldiIsIm5leHQiLCJhdHRyaWJ1dGUiLCJfYXR0cmlidXRlIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsImFyZUVxdWFsIiwicHJldlByb3BzIiwicHJldlN0eWxlIiwicHJldlJlc3QiLCJuZXh0U3R5bGUiLCJuZXh0UmVzdCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsIm5leHRTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-window/dist/index.esm.js\n");

/***/ })

};
;